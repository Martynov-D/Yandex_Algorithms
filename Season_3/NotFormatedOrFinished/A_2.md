## 16

Рассмотрим последовательность целых чисел длины n. По ней с шагом 1 двигается «окно» длины k, то есть сначала в «окне» видны первые k чисел, на следующем шаге в «окне» уже будут находиться k чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить минимум в нём.

### Формат ввода

В первой строке входных данных содержатся два натуральных числа n и k (n ≤ 1.5 * 10<sup>5</sup>, k ≤ 10<sup>4</sup>, k ≤ n) – длины последовательности и «окна», соответственно. На следующей строке находятся n чисел – сама последовательность.

### Формат вывода

Выходые данные должны содержать n - k + 1 строк – минимумы для каждого положения «окна».

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 7 3<br>1 3 2 4 5 3 1 | 1<br>2<br>2<br>3<br>1 |

O(nlog(k)) ~ 10<sup>9</sup> * 1.5
```python
class Heap:
    def __init__(self, array, heap2seq):
        self.heap2seq = heap2seq
        self.seq2heap = {k: idx for idx, k in enumerate(heap2seq)}
        self.array = array
        self.heapify()

    def siftup(self, k=0):
        if not k:
            k = len(self.heap2seq) - 1
        parent = (k - 1) // 2
        while k > 0 and self.array[self.heap2seq[k]] < self.array[self.heap2seq[parent]]:
            # Свап индексов
            self.seq2heap[self.heap2seq[k]], self.seq2heap[self.heap2seq[parent]] = self.seq2heap[self.heap2seq[parent]], self.seq2heap[self.heap2seq[k]]
            # Свап элементов в куче
            self.heap2seq[k], self.heap2seq[parent] = self.heap2seq[parent], self.heap2seq[k]
            k = (k - 1) // 2
            parent = (k - 1) // 2
        
    def siftdown(self, k=0):
        # Пока индекс потомка не вышел за границу массива
        while k * 2 <= len(self.heap2seq) - 2:
            min_child = 2 * k + 1
            # Берем второго ребенка, если он существует и меньше
            if min_child + 1 < len(self.heap2seq) and self.array[self.heap2seq[min_child + 1]] < self.array[self.heap2seq[min_child]]:
                min_child += 1
            # Выходим, если выполняется свойство кучи
            if self.array[self.heap2seq[k]] < self.array[self.heap2seq[min_child]]:
                return
            # Свап индексов
            self.seq2heap[self.heap2seq[k]], self.seq2heap[self.heap2seq[min_child]] = self.seq2heap[self.heap2seq[min_child]], self.seq2heap[self.heap2seq[k]]
            # Свап элементов в куче
            self.heap2seq[k], self.heap2seq[min_child] = self.heap2seq[min_child], self.heap2seq[k]
            k = min_child

    def heapify(self):
        for k in range(len(self.heap2seq) // 2, -1, -1):
            self.siftdown(k)

    def replace(self, old_idx, new_idx):
        old_element = self.array[old_idx]
        # Заменяем в куче старый элемент на новый
        self.heap2seq[self.seq2heap[old_idx]] = new_idx
        # Добавляем связку индексов в словарь и удаляем старую
        self.seq2heap[new_idx] = self.seq2heap[old_idx]
        del self.seq2heap[old_idx]
        # Просеиваем вниз или вверх в зависимости от значения замененного элемента
        if old_element < self.array[new_idx]:
            self.siftdown(self.seq2heap[new_idx])
        elif old_element > self.array[new_idx]:
            self.siftup(self.seq2heap[new_idx])


def main():
    answer = list()
    with open('input.txt', 'r') as inf:
        sequence_length, window_size = map(int, inf.readline().split())
        sequence = list(map(int, inf.readline().split()))
        heap = Heap(sequence, list(range(window_size)))
        for i in range(window_size, sequence_length):
            answer.append(str(sequence[heap.heap2seq[0]]))
            heap.replace(i - window_size, i)
        answer.append(str(sequence[heap.heap2seq[0]]))
    with open('output.txt', 'w') as outf:
        outf.write('\n'.join(answer))
```

O(n)
```python
class Dequeue:
    def __init__(self, capacity=20):
        # Capacity + 1 - заплатка для заплатки. Чтобы не было ложных срабатываний в push_back при указателях равных нулю
        self.memory = [0 for _ in range(capacity + 1)]
        self.begin = 0
        self.end = 0
        self.size = 0

    def push_back(self, n):
        self.memory[self.end] = n
        # Эта заплатка, которая должна работать только для пустой деки с указателями на начало 0 и конец 0,
        # срабатывает в случае полного заполнения, когда:
        # 1. Начало в первом элементе (указатель на первый свободный слева == (1 - 1) % 3 = 0)
        # 2. Конец в первом элементе (указатель на первый свободный справа (2 + 1) % 3 = 0)
        if self.begin == self.end == 0:
            self.begin = (self.begin - 1) % len(self.memory)
        self.end = (self.end + 1) % len(self.memory)
        self.size += 1

    def pop_front(self):
        if self.size > 0:
            temp = self.memory[(self.begin + 1) % len(self.memory)]
            self.begin = (self.begin + 1) % len(self.memory)
            self.size -= 1
            return (True, temp)
        else:
            return (False, )

    def pop_back(self):
        if self.size > 0:
            temp = self.memory[(self.end - 1) % len(self.memory)]
            self.end = (self.end - 1) % len(self.memory)
            self.size -= 1
            return (True, temp)
        else:
            return (False, )

    def front(self):
        if self.size > 0:
            return (True, self.memory[(self.begin + 1) % len(self.memory)])
        else:
            return (False, )

    def back(self):
        if self.size > 0:
            return (True, self.memory[(self.end - 1) % len(self.memory)])
        else:
            return (False, )


def main():
    answer = list()
    with open('input.txt', 'r') as inf:
        sequence_length, window_size = map(int, inf.readline().split())
        sequence = list(map(int, inf.readline().split()))

        deque = Dequeue(window_size)
        for i in range(sequence_length):
            # Первые window_size итераций кладем в очередь все числа, попавшие в окно в самом начале.
            if i >= window_size:
                # В остальные итерации записываем в ответ первый на выход элемент очереди,
                # который одновременно является минимумом
                answer.append(str(deque.front()[1]))
                # Если минимум оказался тем элементом, который выходит за рамку окна,
                # убираем его из очереди
                if deque.front()[1] == sequence[i - window_size]:
                    deque.pop_front()
            # Только что попавший в окно элемент выталкивает из очереди все, что строго больше него,
            # так как вытолкнутые бОльшие числа уйдут из окна раньше текущего элемента,
            # а минимумами им стать не суждено.
            return_value = deque.back()
            while return_value[0] and return_value[1] > sequence[i]:
                deque.pop_back()
                return_value = deque.back()
            deque.push_back(sequence[i])
        # Не забываем про минимум в последнем окне
        answer.append(str(deque.front()[1]))
    with open('output.txt', 'w') as outf:
        outf.write('\n'.join(answer))
```

## 17

Гоблины Мглистых гор очень любях ходить к своим шаманам. Так как гоблинов много, к шаманам часто образуются очень длинные очереди. А поскольку много гоблинов в одном месте быстро образуют шумную толку, которая мешает шаманам проводить сложные медицинские манипуляции, последние решили установить некоторые правила касательно порядка в очереди.
Обычные гоблины при посещении шаманов должны вставать в конец очереди. Привилегированные же гоблины, знающие особый пароль, встают ровно в ее середину, причем при нечетной длине очереди они встают сразу за центром.
Так как гоблины также широко известны своим непочтительным отношением ко всяческим правилам и законам, шаманы попросили вас написать программу, которая бы отслеживала порядок гоблинов в очереди.

### Формат ввода

В первой строке входных данный записано число N (1 ≤ N ≤ 10<sup>5</sup>) — количество запросов к программе. Следующие N строк содержат описание запросов в формате:<br>
"+ i" — гоблин с номером i (1 ≤ i ≤ N) встает в конец очереди.<br>
"* i" — привилегированный гоблин с номером i встает в середину очереди.<br>
"-" — первый гоблин из очереди уходит к шаманам. Гарантируется, что на момент такого запроса очередь не пуста.

### Формат вывода

Для каждого запроса типа ”-” программа должна вывести номер гоблина, который должен зайти к шаманам.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 7<br>+ 1<br>+ 2<br>-<br>+ 3<br>+ 4<br>-<br>- | 1 2 3 |

```python
from collections import deque


def main():
    first = deque()
    second = deque()
    answer = list()
    with open('input.txt', 'r') as inf:
        number_of_queries = int(inf.readline())
        for _ in range(number_of_queries):
            query = inf.readline().split()
            match query[0]:
                case '-':
                    answer.append(str(first.popleft()))
                case '+':
                    second.append(int(query[1]))
                case '*':
                    second.appendleft(int(query[1]))
            # Балансировка очередей, чтобы место для вставки с приоритетом было актуально
            if len(second) > len(first):
                first.append(second.popleft())
    print('\n'.join(answer))
```

## 18

На вокзале есть K тупиков, куда прибывают электрички. Этот вокзал является их конечной станцией, поэтому электрички, прибыв, некоторое время стоят на вокзале, а потом отправляются в новый рейс (в ту сторону, откуда прибыли).
Дано расписание движения электричек, в котором для каждой электрички указано время ее прибытия, а также время отправления в следующий рейс. Электрички в расписании упорядочены по времени прибытия. Поскольку вокзал — конечная станция, то электричка может стоять на нем довольно долго, в частности, электричка, которая прибывает раньше другой, отправляться обратно может значительно позднее.
Тупики пронумерованы числами от 1 до K. Когда электричка прибывает, ее ставят в свободный тупик с минимальным номером. При этом если электричка из какого-то тупика отправилась в момент времени X, то электричку, которая прибывает в момент времени X, в этот тупик ставить нельзя, а электричку, прибывающую в момент X+1 — можно.
Напишите программу, которая по данному расписанию для каждой электрички определит номер тупика, куда прибудет эта электричка.

### Формат ввода

Сначала вводятся число K — количество тупиков и число N — количество электропоездов (1 ≤ K≤100000, 1 ≤ N ≤ 100000). Далее следуют N строк, в каждой из которых записано по 2 числа: время прибытия и время отправления электрички. Время задается натуральным числом, не превышающим 109. Никакие две электрички не прибывают в одно и то же время, но при этом несколько электричек могут отправляться в одно и то же время. Также возможно, что какая-нибудь электричка (или даже несколько) отправляются в момент прибытия какой-нибудь другой электрички. Время отправления каждой электрички строго больше времени ее прибытия.
Все электрички упорядочены по времени прибытия. Считается, что в нулевой момент времени все тупики на вокзале свободны.

### Формат вывода

Выведите N чисел — по одному для каждой электрички: номер тупика, куда прибудет соответствующая электричка. Если тупиков не достаточно для того, чтобы организовать движение электричек согласно расписанию, выведите два числа: первое должно равняться 0 (нулю), а второе содержать номер первой из электричек, которая не сможет прибыть на вокзал.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 1 1<br>2 5 | 1 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 1 2<br>2 5<br>5 6 | 0 2 |

```python
import heapq


def main():
    with open('input.txt', 'r') as inf:
        n_dead_ends, n_trains = map(int, inf.readline().split())
        events = list()
        for idx in range(n_trains):
            arrival, departure = map(int, inf.readline().split())
            events.append([arrival, -1, idx])
            events.append([departure, 1, idx])
        # Сохранили время приезда и отъезда каждого поезда как событие. Отсортировали события по времени.
        events.sort()

    # В начале в куче минимумов лежат все тупики.
    # Идем по всем событиям. Если приехал поезд, достаем из кучи минимум. Если поезд ушел, добавляем в кучу номер тупика.
    heap = list(range(n_dead_ends, 0, -1))
    heapq.heapify(heap)
    train2deadend = {i : -1 for i in range(n_trains)}
    for time_, type_, idx in events:
        match type_:
            case -1:
                if len(heap) == 0:
                    print(0, idx + 1)
                    return
                train2deadend[idx] = heapq.heappop(heap)
            case 1:
                heapq.heappush(heap, train2deadend[idx])
    print(' '.join([str(dead_end) for dead_end in train2deadend.values()]))
```

## 19

Фирма OISAC выпустила новую версию калькулятора. Этот калькулятор берет с пользователя деньги за совершаемые арифметические операции. Стоимость каждой операции в долларах равна 5% от числа, которое является результатом операции. На этом калькуляторе требуется вычислить сумму N натуральных чисел (числа известны). Нетрудно заметить, что от того, в каком порядке мы будем складывать эти числа, иногда зависит, в какую сумму денег нам обойдется вычисление суммы чисел (тем самым оказывается нарушен классический принцип “от перестановки мест слагаемых сумма не меняется”).
Например, пусть нам нужно сложить числа 10, 11, 12 и 13. Тогда если мы сначала сложим 10 и 11 (это обойдется нам в 1.05 €), потом результат с 12 (1.65 €), и затем с 13 (2.3 €), то всего мы заплатим 5 €, если же сначала отдельно сложить 10 и 11 (1.05 €), потом 12 и 13 (1.25 €) и, наконец, сложить между собой два полученных числа (2.3 €), то в итоге мы заплатим лишь 4.6 €. Напишите программу, которая будет определять, за какую минимальную сумму денег можно найти сумму данных N чисел.

### Формат ввода

Первая строка входных данных содержит число N (2 ≤ N ≤ 10<sup>5</sup>). Во второй строке заданы N натуральных чисел, каждое из которых не превосходит 10000.

### Формат вывода

Определите, сколько денег нам потребуется на нахождения суммы этих N чисел. Результат должен быть выведен с двумя знаками после десятичной точки.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 4<br>10 11 12 13 | 4.60 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 2<br>1 1 | 0.10 |

```python
import heapq

def main():
    with open('input.txt', 'r') as inf:
        n_of_numbers = int(inf.readline())
        numbers = list(map(int, inf.readline().split()))
    heapq.heapify(numbers)
        
    sum = 0
    while len(numbers) > 1:
        temp = heapq.heappop(numbers) + heapq.heappop(numbers)
        sum += temp * 0.05
        heapq.heappush(numbers, temp)
    print("%.2f" % sum)
```

## 20

Петя, которому три года, очень любит играть с машинками. Всего у Пети N различных машинок, которые хранятся на полке шкафа так высоко, что он сам не может до них дотянуться. Одновременно на полу комнаты может находиться не более K машинок. Петя играет с одной из машинок на полу и если он хочет поиграть с другой машинкой, которая также находится на полу, то дотягивается до нее сам. Если же машинка находится на полке, то он обращается за помощью к маме. Мама может достать для Пети машинку с полки и одновременно с этим поставить на полку любую машинку с пола. Мама очень хорошо знает своего ребенка и может предугадать последовательность, в которой Петя захочет играть с машинками. При этом, чтобы не мешать Петиной игре, она хочет совершить как можно меньше операций по подъему машинки с пола, каждый раз правильно выбирая машинку, которую следует убрать на полку. Ваша задача состоит в том, чтобы определить минимальное количество операций. Перед тем, как Петя начал играть, все машинки стоят на полке.

### Формат ввода

В первой строке содержаться три числа N, K и P (1 ≤ K ≤ N ≤ 10<sup>5</sup>, 1 ≤ P ≤ 5 * 10<sup>5</sup>). В следующих P строках записаны номера машинок в том порядке, в котором Петя захочет играть с ними.

### Формат вывода

Выведите единственное число: минимальное количество операций, которое надо совершить Петиной маме.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 3 2 7<br>1<br>2<br>3<br>1<br>3<br>1<br>2 | 4 |

```python

```