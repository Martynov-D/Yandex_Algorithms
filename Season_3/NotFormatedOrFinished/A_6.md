## 36

На стандартной шахматной доске (8х8) живут 2 шахматных коня: Красный и Зеленый. Обычно они беззаботно скачут по просторам доски, пощипывая шахматную травку, но сегодня особенный день: у Зеленого коня День Рождения. Зеленый конь решил отпраздновать это событие вместе с Красным. Но для осуществления этого прекрасного плана им нужно оказаться на одной клетке. Заметим, что Красный и Зеленый шахматные кони сильно отличаются от черного с белым: они ходят не по очереди, а одновременно, и если оказываются на одной клетке, никто никого не съедает. Сколько ходов им потребуется, чтобы насладиться праздником?

### Формат ввода

На вход программы поступают координаты коней, записанные по стандартным шахматным правилам (т.е. двумя символами - маленькая латинская буква (от a до h) и цифра (от 1 до 8), задающие столбец и строку соответственно).

### Формат вывода

Требуется вывести наименьшее необходимое количество ходов, либо число -1, если кони не могут встретиться.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| a1 a2 | -1 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| a1 a3 | 1 |

<i>Example 3:</i>

| In  | Out |
|:----|:---:|
| h1 a8 | 3 |

```python
import queue

def main():
    di = [-2, -2, -1, -1, 1, 1, 2, 2]
    dj = [-1, 1, -2, 2, -2, 2, -1, 1]

    with open('input.txt', 'r') as inf:
        first_knight, second_knight = inf.readline().split()

    # Буквы в числа
    first_knight = (ord(first_knight[0]) - ord('a'), int(first_knight[1]) - 1, 1)
    second_knight = (ord(second_knight[0]) - ord('a'), int(second_knight[1]) - 1, 1)

    # За первый проход считаем количество ходов до каждого поля доски для первого коня
    q = queue.Queue()
    distances = [[-1 for _ in range(8)] for _ in range(8)]
    q.put(first_knight)
    distances[first_knight[0]][first_knight[1]] = 0
    while not q.empty():
        cell = q.get()
        i, j, steps = cell
        for k in range(8):
            idi = i + di[k]
            jdj = j + dj[k]
            if 0 <= idi < 8 and 0 <= jdj < 8:
                if distances[idi][jdj] == -1:
                    distances[idi][jdj] = steps
                    q.put((idi, jdj, steps + 1))
    
    # За второй проход накапливаем количество ходов для второго коня и проверяем,
    # не попал ли он в одну и ту же клетку с первым на этом этапе
    visited = [[False for _ in range(8)] for _ in range(8)]
    q.put(second_knight)
    visited[second_knight[0]][second_knight[1]] = True
    answer = -1
    while not q.empty() and answer == -1:
        cell = q.get()
        i, j, steps = cell
        for k in range(8):
            idi = i + di[k]
            jdj = j + dj[k]
            if 0 <= idi < 8 and 0 <= jdj < 8:
                if not visited[idi][jdj]:
                    if distances[idi][jdj] == steps:
                        answer = steps
                    visited[idi][jdj] = True
                    q.put((idi, jdj, steps + 1))
    print(answer)
```

## 37

Витя хочет придумать новую игру с числами. В этой игре от игроков требуется преобразовывать четырехзначные числа не содержащие нулей при помощи следующего разрешенного набора действий:
1. Можно увеличить первую цифру числа на 1, если она не равна 9.
2. Можно уменьшить последнюю цифру на 1, если она не равна 1.
3. Можно циклически сдвинуть все цифры на одну вправо.
4. Можно циклически сдвинуть все цифры на одну влево.

Например, применяя эти правила к числу 1234 можно получить числа 2234, 1233, 4123 и 2341 соответственно. Точные правила игры Витя пока не придумал, но пока его интересует вопрос, как получить из одного числа другое за минимальное количество операций.

### Формат ввода

Во входном файле содержится два различных четырехзначных числа, каждое из которых не содержит нулей.

### Формат вывода

Программа должна вывести последовательность четырехзначных чисел, не содержащих нулей. Последовательность должна начинаться первым из данных чисел и заканчиваться вторым из данных чисел, каждое последующее число в последовательности должно быть получено из предыдущего числа применением одного из правил. Количество чисел в последовательности должно быть минимально возможным.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 1234<br>4321 | 1234<br>2234<br>3234<br>4323<br>4322<br>4321 |

```python
import queue

def get_states(state: str):
    states = list()
    # Увеличить первую цифру, если она меньше 9
    if int(state[0]) < 9:
        states.append(str(int(state[0]) + 1) + state[1:])
    # Уменьшить последнюю цифру, если она больше 1
    if int(state[-1]) > 1:
        states.append(state[:-1] + str(int(state[-1]) - 1))

    # Циклический сдвиг на одну позицию вправо
    temp = list(state)
    temp[0], temp[-1] = temp[-1], temp[0]
    temp[1], temp[-1] = temp[-1], temp[1]
    temp[2], temp[-1] = temp[-1], temp[2]
    states.append(''.join(temp))
    # Циклический сдвиг на одну позицию влево
    temp = list(state)
    temp[0], temp[-1] = temp[-1], temp[0]
    temp[0], temp[-2] = temp[-2], temp[0]
    temp[0], temp[-3] = temp[-3], temp[0]
    states.append(''.join(temp))

    return states


def main():
    with open('input.txt', 'r') as inf:
        start = inf.readline().strip()
        end = inf.readline().strip()

    graph = dict()
    q = queue.Queue()
    q.put(start)
    flag = False
    while not flag:
        current_state = q.get()
        states = get_states(current_state)
        for state in states:
            if state not in graph:
                graph[state] = current_state
                q.put(state)
            if state == end:
                flag = True

    path = [end]
    while end != start:
        end = graph[end]
        path.append(end)
    print('\n'.join(path[::-1]))
```

## 38

Игрушечный лабиринт представляет собой прозрачную плоскую прямоугольную коробку, внутри которой есть препятствия и перемещается шарик. Лабиринт можно наклонять влево, вправо, к себе или от себя, после каждого наклона шарик перемещается в заданном направлении до ближайшего препятствия или до стенки лабиринта, после чего останавливается. Целью игры является загнать шарик в одно из специальных отверстий – выходов. Шарик проваливается в отверстие, если оно встречается на его пути (шарик не обязан останавливаться в отверстии).
Первоначально шарик находится в левом верхнем углу лабиринта. Гарантируется, что решение существует и левый верхний угол не занят препятствием или отверстием.

### Формат ввода

В первой строке входного файла записаны числа N и M – размеры лабиринта (целые положительные числа, не превышающие 100). Затем идет N строк по M чисел в каждой – описание лабиринта. Число 0 в описании означает свободное место, число 1 – препятствие, число 2 – отверстие.

### Формат вывода

Выведите единственное число – минимальное количество наклонов, которые необходимо сделать, чтобы шарик покинул лабиринт через одно из отверстий.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 4 5<br>0 0 0 0 1<br>0 1 1 0 2<br>0 2 1 0 0<br>0 0 1 0 0 | 3 |

```python
import queue


def main():
    with open('input.txt', 'r') as inf:
        rows, cols = map(int, inf.readline().split())
        graph = {(i, j): list() for i in range(rows) for j in range(cols)}
        field = [list() for _ in range(rows)]
        exit_cells = list()
        for i in range(rows):
            field[i] = inf.readline().split()
            for j in range(cols):
                if field[i][j] == '2':
                    exit_cells.append((i, j))
            
    # Для каждой строки и для каждого столбца найти левую, правую и верхнюю, нижнюю гранциы соответственно.
    # Добавить вершине графа эти ячейки как соседей
    for i in range(rows):
        b = 0
        while field[i][b] == '1':
            b+= 1
        left_border = b
        b += 1
        while b < cols:
            match field[i][b]:
                # Если ноль, то добавляем этому полю левую границу как левого соседа.
                # Если один, то это на клетку дальше правой границы. Надо всем предыдущим ячейкам добавить соседа "граница - 1" и переместить левую границу.
                # Если два, то это правая граница. Надо всем предыдущим - 1 ячейкам добавить срседа "граница" и переместить левую границу.
                # Левая граница - та ячейка, в которую попадет шарик, если наклонить лабиринт влево.
                case '0':
                    if b != left_border:
                        graph[(i, b)].append((i, left_border))
                case '1':
                    for j in range(left_border, b - 1):
                        graph[(i, j)].append((i, b - 1))
                    left_border = b + 1
                case '2':
                    for j in range(left_border, b):
                        graph[(i, j)].append((i, b))
                    left_border = b
            b += 1
        # Если справа не оказалось преграды (то есть там стена лабиринта),
        # то надо всем оставшимся клеткам кроме крайней добавить в соседи крайнюю клетку поля.
        if left_border < cols - 1:
            for j in range(left_border, cols - 1):
                graph[(i, j)].append((i, cols - 1))

    # Повторить для всех столбцов.
    for j in range(cols):
        b = 0
        while field[b][j] == '1':
            b+= 1
        upper_border = b
        b += 1
        while b < rows:
            match field[b][j]:
                case '0':
                    if b != upper_border:
                        graph[(b, j)].append((upper_border, j))
                case '1':
                    for i in range(upper_border, b - 1):
                        graph[(i, j)].append((b - 1, j))
                    upper_border = b + 1
                case '2':
                    for i in range(upper_border, b):
                        graph[(i, j)].append((b, j))
                    upper_border = b
            b += 1
        if upper_border < rows - 1:
            for i in range(upper_border, rows - 1):
                if field[i][j] != '2':
                    graph[(i, j)].append((rows - 1, j))
    
    # BFS
    q = queue.Queue()
    distances = [[-1 for _ in range(cols)] for _ in range(rows)]
    q.put((0, 0))
    distances[0][0] = 0

    while not q.empty():
        cell = q.get()
        i, j = cell
        distance = distances[i][j] + 1
        for neighbour in graph[cell]:
            if distances[neighbour[0]][neighbour[1]] == -1:
                distances[neighbour[0]][neighbour[1]] = distance
                if field[neighbour[0]][neighbour[1]] != '2':
                    q.put(neighbour)
    
    min_distance = rows * cols + 1
    for i, j in exit_cells:
        if distances[i][j] < min_distance:
            min_distance = distances[i][j]
    print(min_distance)
```

## 39

В подземелье есть N залов, соединенных туннелями. В некоторых залах находятся роботы, которые одновременно получили команду собраться в одном месте.
Роботы устроены так, что, получив команду, они все начали двигаться с такой скоростью, что туннель между двумя любыми залами преодолевают за 1 минуту. Роботы не могут останавливаться (в том числе и в залах), а также менять направление движения, находясь в туннелях (однако попав в зал, робот может из него пойти по тому же туннелю, по которому он пришел в этот зал).

Напишите программу, вычисляющую, через какое минимальное время все роботы смогут собраться вместе (в зале или в туннеле).

### Формат ввода

Сначала на вход программы поступают числа N — количество залов (1 ≤ N ≤ 400) и K — количество туннелей (1 ≤ K ≤ 20000). Далее вводится K пар чисел, каждая пара описывает номера залов, соединяемых туннелем (по туннелю можно перемещаться в обе стороны). Между двумя залами может быть несколько туннелей. Туннель может соединять зал с самим собой. Далее следует число M (1 ≤ M ≤ 400) — количество роботов. Затем вводятся M чисел, задающих номера залов, где вначале расположены роботы. В одном зале может быть несколько роботов.

### Формат вывода

Выведите минимальное время в минутах, через которое роботы могут собраться вместе. Если роботы никогда не смогут собраться вместе, выведите одно число –1 (минус один).

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 4 5<br>1 2<br>2 3<br>3 4<br>1 4<br>1 3<br>3<br>1 2 4 | 1 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 3 2<br>1 2<br>2 3<br>2<br>1 3 | 1 |

<i>Example 3:</i>

| In  | Out |
|:----|:---:|
| 7 7<br>1 2<br>2 3<br>3 4<br>4 1<br>1 3<br>2 6<br>6 7<br>3<br>7 2 4 | 2 |

```python

```

## 40

### Формат ввода

### Формат вывода

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
|     |     |

```python

```