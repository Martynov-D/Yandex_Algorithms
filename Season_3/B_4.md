## 26

В каждой клетке прямоугольной таблицы N*M записано некоторое число. Изначально игрок находится в левой верхней клетке. За один ход ему разрешается перемещаться в соседнюю клетку либо вправо, либо вниз (влево и вверх перемещаться запрещено). При проходе через клетку с игрока берут столько килограммов еды, какое число записано в этой клетке (еду берут также за первую и последнюю клетки его пути).
Требуется найти минимальный вес еды в килограммах, отдав которую игрок может попасть в правый нижний угол.

### Формат ввода

Вводятся два числа N и M — размеры таблицы (1 ≤ N ≤ 20, 1 ≤ M ≤ 20). Затем идет N строк по M чисел в каждой — размеры штрафов в килограммах за прохождение через соответствующие клетки (числа от 0 до 100).

### Формат вывода

Выведите минимальный вес еды в килограммах, отдав которую можно попасть в правый нижний угол.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 5 5<br>1 1 1 1 1<br>3 100 100 100 100<br>1 1 1 1 1<br>2 2 2 2 1<br>1 1 1 1 1 | 11 |

```python
def main():
    n, m = map(int, input().split())
    table = list()
    for _ in range(n):
        table.append(list(map(int, input().split())))
    
    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
    # Барьер из бесконечностей, чтобы не обрабатывать отдельно первую строку
    # и элементы первого столбца на кадой итерации цикла
    for i in range(n + 1):
        dp[i][0] = float('inf')
    for j in range(2, m + 1):
        dp[0][j] = float('inf')

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + table[i - 1][j - 1]
    print(dp[-1][-1])
```

## 27

В левом верхнем углу прямоугольной таблицы размером N*M находится черепашка. В каждой клетке таблицы записано некоторое число. Черепашка может перемещаться вправо или вниз, при этом маршрут черепашки заканчивается в правом нижнем углу таблицы.
Подсчитаем сумму чисел, записанных в клетках, через которую проползла черепашка (включая начальную и конечную клетку). Найдите наибольшее возможное значение этой суммы и маршрут, на котором достигается эта сумма.

### Формат ввода

В первой строке входных данных записаны два натуральных числа N и M, не превосходящих 100 — размеры таблицы. Далее идет N строк, каждая из которых содержит M чисел, разделенных пробелами — описание таблицы. Все числа в клетках таблицы целые и могут принимать значения от 0 до 100.

### Формат вывода

Первая строка выходных данных содержит максимальную возможную сумму, вторая — маршрут, на котором достигается эта сумма. Маршрут выводится в виде последовательности, которая должна содержать N-1 букву D, означающую передвижение вниз и M-1 букву R, означающую передвижение направо. Если таких последовательностей несколько, необходимо вывести ровно одну (любую) из них.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 5 5<br>9 9 9 9 9<br>3 0 0 0 0<br>9 9 9 9 9<br>6 6 6 6 8<br>9 9 9 9 9 | 74<br>D D R R R R D D |

```python
def main():
    with open('input.txt', 'r') as inf:
        n, m = map(int, inf.readline().split())
        table = list()
        for _ in range(n):
            table.append(list(map(int, inf.readline().split())))
    
    # Барьер из нулей слева (m + 1) и сверху (n + 1), чтобы не обрабатывать отдельно первую строку
    # и элементы первого столбца на кадой итерации цикла
    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) + table[i - 1][j - 1]

    route = list()
    i = n 
    j = m
    temp = ''
    for _ in range(n + m - 2):
        if i > 1 and (dp[i - 1][j] >= dp[i][j - 1] or j == 1):
            temp = 'D'
            i -= 1
        else:
            temp = 'R'
            j -= 1
        route.append(temp)
    print(dp[-1][-1])
    print(' '.join(route[::-1]))
```

## 28

Дана прямоугольная доска N × M (N строк и M столбцов). В левом верхнем углу находится шахматный конь, которого необходимо переместить в правый нижний угол доски. В данной задаче конь может перемещаться на две клетки вниз и одну клетку вправо или на одну клетку вниз и две клетки вправо.
Необходимо определить, сколько существует различных маршрутов, ведущих из левого верхнего в правый нижний угол.

### Формат ввода

Входной файл содержит два натуральных числа N и M (1 ≤ N, M ≤ 50)

### Формат вывода

В выходной файл выведите единственное число — количество способов добраться конём до правого нижнего угла доски.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 3 2 | 1 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 31 34 | 293930 |

```python
def main():
    with open('input.txt', 'r') as inf:
        n, m = map(int, inf.readline().split())

    dp = [[0 for _ in range(m)] for _ in range(n)]
    # Первые ходы из точки (0;0), если их можно сделать - база динамики
    dp[0][0] = 1
    if n > 1 and m > 2:
        dp[1][2] = 1
    if n > 2 and m > 1:
        dp[2][1] = 1
    
    for i in range(2, n):
        for j in range(2, m):
            dp[i][j] = dp[i - 2][j - 1] + dp[i - 1][j - 2]
    
    print(dp[-1][-1])
```

## 29

Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок: при каждой покупке более чем на 100 рублей покупатель получает купон, дающий право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).
Однажды Пете на глаза попался прейскурант на ближайшие N дней. Внимательно его изучив, он решил, что будет обедать в этом кафе все N дней, причем каждый день он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая, и поэтому он хочет по максимуму использовать предоставляемую систему скидок так, чтобы его суммарные затраты были минимальны. Требуется найти минимально возможную суммарную стоимость обедов и номера дней, в которые Пете следует воспользоваться купонами.

### Формат ввода

В первой строке входного файла записано целое число N (0 ≤ N ≤ 100). В каждой из последующих N строк записано одно целое число, обозначающее стоимость обеда в рублях на соответствующий день. Стоимость — неотрицательное целое число, не превосходящее 300.

### Формат вывода

В первой строке выдайте минимальную возможную суммарную стоимость обедов. Во второй строке выдайте два числа K1 и K2 — количество купонов, которые останутся неиспользованными у Пети после этих N дней и количество использованных им купонов соответственно.
В последующих K2 строках выдайте в возрастающем порядке номера дней, когда Пете следует воспользоваться купонами. Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них, в котором значение K1 максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе). Если таких решений несколько, выведите любое из них.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 5<br>35<br>40<br>101<br>59<br>63 | 235<br>0 1<br>5 |

```python
def main():
    with open('input.txt', 'r') as inf:
        number_of_days = int(inf.readline())
        price_per_day = list()
        for _ in range(number_of_days):
            price_per_day.append(int(inf.readline()))
    
    payed_with_ticket = list()
    if number_of_days == 1:
        general_cost = price_per_day[0]
        tickets = 1 if price_per_day[0] > 100 else 0

    else:
        dp = [[0 for _ in range(number_of_days + 2)] for _ in range(number_of_days + 1)]
        # Делаем барьеры: один из первой строки, два других из первого и последнего столбца.
        # Они нужны, чтобы отдельно не обрабатывать краевые случаи.
        border = float('inf')
        for j in range(0, number_of_days + 2):
            dp[0][j] = border
        dp[0][1] = 0
        for i in range(1, number_of_days + 1):
            dp[i][0] = border
            dp[i][-1] = border

        for i in range(1, number_of_days + 1):
            for j in range(1, number_of_days + 1):
                if price_per_day[i - 1] > 100:
                    # Либо тратим купон (приходим из j + 1), либо покупаем обед и получаем купон (приходим из j - 1)
                    dp[i][j] = min(dp[i - 1][j - 1] + price_per_day[i - 1], dp[i - 1][j + 1])
                else:
                    # Либо тратим купон (приходим из j + 1), либо покупаем обед, но не получаем купон из-за низкой цены
                    dp[i][j] = min(dp[i - 1][j] + price_per_day[i - 1], dp[i - 1][j + 1])

        idx = 0
        general_cost = dp[-1][0]
        # Идем от максимального количества купонов до минимального, ищем минимум среди общей стоимости обедов.
        # Проходя таким образом и обновляя ответ только в случае строгого неравенства,
        # позволит найти еще и максимальное количество купонов, которое останется (индекс элемента в последней строке).
        for j in range(number_of_days + 1, 0, -1):
            if dp[-1][j] < general_cost:
                general_cost = dp[-1][j]
                idx = j
        
        tickets = idx - 1
        day = number_of_days
        for day in range(number_of_days, 0, -1):
            
            if dp[day - 1][idx + 1] == dp[day][idx]:
                idx += 1
                payed_with_ticket.append(day)
            elif dp[day][idx] == dp[day - 1][idx] + price_per_day[day - 1]:
                pass
            else:
                idx -= 1

    print(general_cost)
    print(tickets, len(payed_with_ticket))
    if len(payed_with_ticket) > 0:
        print(*payed_with_ticket[::-1])
```

## 30

Даны две последовательности, требуется найти и вывести их наибольшую общую подпоследовательность.

### Формат ввода

В первой строке входных данных содержится число N – длина первой последовательности (1 ≤ N ≤ 1000). Во второй строке заданы члены первой последовательности (через пробел) – целые числа, не превосходящие 10000 по модулю.
В третьей строке записано число M – длина второй последовательности (1 ≤ M ≤ 1000). В четвертой строке задаются члены второй последовательности (через пробел) – целые числа, не превосходящие 10000 по модулю.

### Формат вывода

Требуется вывести наибольшую общую подпоследовательность данных последовательностей, через пробел.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 3<br>1 2 3<br>3<br>2 3 1 | 2 3 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 3<br>1 2 3<br>3<br>3 2 1 | 1 |

<i>Example 3:</i>

| In  | Out |
|:----|:---:|
| 10<br>1 2 3 4 5 6 7 8 9 10<br>100<br>17 17 17 18 18 18 19 19 19 20 17 17 17 18 18 18 19 19 19 20 17 17 17 18 18 18 19 19 19 20 17 17 17 18 18 18 19 19 19 20 17 17 17 18 18 18 19 19 19 20 17 17 17 18 18 18 19 19 19 20 17 17 17 18 18 18 19 19 19 20 17 17 17 18 18 18 19 19 19 20 100 1 100 2 3 100 100 100 4 100 5 100 100 100 6 7 8 9 100 10 | 1 2 3 4 5 6 7 8 9 10 |

```python
def main():
    with open('input.txt', 'r') as inf:
        f = int(inf.readline())
        first = list(map(int, inf.readline().split()))
        s = int(inf.readline())
        second = list(map(int, inf.readline().split()))
    
    dp = [[0 for _ in range(s + 1)] for _ in range(f + 1)]
    for i in range(1, f + 1):
        for j in range(1, s + 1):
            # Если элементы последовательностей совпали, то берем предыдущий элемент с главной диагонали + 1.
            # Иначе максимум из элемента выше и элемента левее
            dp[i][j] = dp[i - 1][j - 1] + 1 if first[i - 1] == second[j - 1] else max(dp[i][j - 1], dp[i - 1][j])
    
    i = f
    j = s
    k = 0
    path = list()
    # Путь в любом случае займет m + n - 1 ходов
    while k < f + s - 1:
        # Если выше и слева не такое же число, что в текущей ячейке,
        # и на главной диагонали выше меньше на 1, значит часть последовательности совпадает.
        if dp[i][j] > dp[i - 1][j - 1] and dp[i][j] != dp[i - 1][j] and dp[i][j] != dp[i][j - 1]:
            path.append(first[i - 1])
            i -= 1
            j -= 1
            k += 1
        # Иначе выбираем, из какой последовательнтсти вычеркнуть (не учесть) элемент
        elif dp[i][j] == dp[i - 1][j] and i > 0:
            i -= 1
        else:
            j -= 1
        k += 1
    
    print(*path[::-1])
```