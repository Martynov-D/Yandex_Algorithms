## 21

Дано натуральное число N. Необходимо представить его в виде суммы точных кубов, содержащей наименьшее число слагаемых. Программа должна вывести это число слагаемых.

### Формат ввода

Программа получает на вход натуральное число N, не превосходящее 10<sup>6</sup>

### Формат вывода

Программа должна вывести единственное натуральное число

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 9 | 2 |

| Сложность | Вердикт |
|---|---|
|O(n * m), где m - длина последовательности кубов, заканчивающейся на первом меньшем или равном n| Time limit |

```python
def main():
    with open('input.txt', 'r') as inf:
        number = int(inf.readline())
    if number == 0:
        print(1)
        return
    
    dp = [0 for _ in range(number + 1)]
    dp[1] = 1

    # Если заданное число является кубом, то список закончится на нем. Если число не куб, то будет посчитано лишнее значение.
    # Чтобы не думать об этом, гарантированно посчитаем на одно значение больше, а потом удалим его.
    cubes = [1]
    i = 2
    while cubes[-1] <= number:
        cubes.append(i * i * i)
        i += 1
    cubes.pop()

    for i in range(2, number + 1):
        min_ = float('inf')
        # Ищем число с минимальным показателем, прибавив куб к которому получим текущее число
        k = 0
        while k < len(cubes) and cubes[k] <= i:
            if dp[i - cubes[k]] < min_:
                min_ = dp[i - cubes[k]]
            k += 1
        dp[i] = min_ + 1
    print(dp[-1])
```

## 22

Дана последовательность, требуется найти её наибольшую возрастающую подпоследовательность.

### Формат ввода

В первой строке входных данных задано число N — длина последовательности (1 ≤ N ≤ 1000). Во второй строке задается сама последовательность (разделитель — пробел). Элементы последовательности — целые числа, не превосходящие 10000 по модулю.

### Формат вывода

Требуется вывести наибольшую возрастающую подпоследовательность данной последовательности. Если таких подпоследовательностей несколько, необходимо вывести одну (любую) из них.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 6<br>3 29 5 5 28 6 | 3 5 28 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 10<br>4 8 2 6 2 10 6 29 58 9 | 4 8 10 29 58 |

```python
def lBinSearch(array, compare_to):
    l = 0
    r = len(array) - 1
    while l < r:
        m = l + (r - l) // 2
        if array[m] > compare_to:
            r = m
        else:
            l = m + 1
    return l


def main():
    with open('input.txt', 'r') as inf:
        sequence_length = int(inf.readline())
        sequence = list(map(int, inf.readline().split()))

    dp = [float('inf') for _ in range(sequence_length + 1)]
    dp[0] = -float('inf')
    pos = [0 for _ in range(sequence_length + 1)]
    pos[0] = -1
    prev = [0 for _ in range(sequence_length)]
    length = 0
 
    for i in range(sequence_length):
        # Бинарным поиском по динамике находим первый элемент (dp[j])
        # строго больший рассматриваемого элемента последовательности (seq[i])
        # и заменяем первый на второй.
        # То есть по каждому индексу динамики будет храниться минимальный элемент,
        # на котором заканчивается подпоследовательность длины равной значению инекса.
        j = lBinSearch(dp, sequence[i])
        if dp[j-1] < sequence[i] and sequence[i] < dp[j]:
            dp[j] = sequence[i]
            # Просто индекс элемента в исходной последовательности
            pos[j] = i
            # Чтобы восстановить ответ сохраняем индекс предыдущего.
            # Сохраняя для всех элементов позицию предыдущего, мы не затрем эти значения, как происходит в динамике,
            # где на каждой позиции всегда хранится минимальный элемент,
            # не всегда стоящий раньше следующего в исходной последовательности чисел.
            prev[i] = pos[j - 1]
            length = max(length, j)
    answer = list()
    p = pos[length]
    while p != -1:
        answer.append(str(sequence[p]))
        p = prev[p]
    
    with open('output.txt', 'w') as outf:
        outf.write(' '.join(answer[::-1]))
```

## 23

Рассмотрим фигуру, аналогичную показанной на рисунке (большой равносторонний треугольник, составленный из маленьких равносторонних треугольников). На рисунке приведена фигура, состоящая из 4-х уровней треугольников.

![img](A3_23.png)

Напишите программу, которая будет определять, сколько всего в ней треугольников (необходимо учитывать не только «маленькие» треугольники, а вообще все треугольники — в частности, нас интересуют треугольник, выделенный жирным, вся фигура).


### Формат ввода

Вводится одно число N — количество уровней в фигуре (1 ≤ N ≤ 10<sup>5</sup>)

### Формат вывода

Выведите количество треугольников в такой фигуре.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 1 | 1 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 2 | 5 |

<i>Example 3:</i>

| In  | Out |
|:----|:---:|
| 4 | 27 |

http://rsdn.org/forum/etude/1489086.flat

```python
def main():
    n = int(input())
    if n % 2 == 0:
        k = n // 2
        s = k * (k + 1) * (4 * k + 1) / 2
    else:
        k = (n - 1) // 2
        s = (k + 1) * (4 * k * k + 7 * k + 2) / 2
    print(int(s))
```

## 24

Папа Карло сменил работу: теперь он работает в мастерской, и целый рабочий день занимается тем, что забивает гвоздики. Чтобы ему было не скучно, у него в мастерской стоит постоянно работающий телевизор. К сожалению, производительность папы Карло напрямую зависит от его настроения, а оно, в свою очередь, — от того, что в данный момент показывают по телевизору. Правда, пока папа Карло забивает гвоздик, он не обращает ни малейшего внимания на телевизор, и поэтому скорость его работы зависит только от того, что показывали по телевизору в тот момент, когда он только начал забивать этот гвоздик. Забив очередной гвоздик, он обязательно мельком смотрит в телевизор (его настроение, естественно, меняется), и после этого может либо сразу начать забивать следующий гвоздик, либо отдохнуть несколько секунд или даже минут за просмотром телевизора.
Папа Карло начинает работу ровно в 9 часов. С 13 часов у него начинается обеденный перерыв. При этом если он незадолго до обеда хочет начать вбивать гвоздик, но понимает, что до перерыва он не закончит эту работу, то он и не начинает ее. Аналогично в 14 часов он вновь приступает к работе, а в 18 уходит домой. Это значит, что в 9:00:00 (аналогично, как и в 14:00:00) он уже может начать забивать гвоздик. Если он хочет начать вбивать гвоздик в 12:59:59 или 17:59:59 и на это у него уйдет 1 секунда, то он успевает вбить гвоздик до обеда или до окончания работы соответственно, а если 2 секунды, — то уже нет.
Известна программа телевизионных передач и то, как они влияют на папу Карло. Требуется составить график работы и маленьких перерывчиков папы Карло так, чтобы за рабочий день он вбил максимально возможное количество гвоздей.

### Формат ввода

Во входном файле записано расписание телевизионных передач с 9:00:00 до 18:00:00 в следующем формате. В первой строке число N — количество телевизионных передач в этот период (1 ≤ N ≤ 32400). В каждой из последующих N строк записано описание одной передачи: сначала время ее начала в формате ЧЧ:ММ:СС (ЧЧ — две цифры, задающие часы, ММ — две цифры, задающие минуты начала, СС — две цифры, задающие секунды начала). А затем через один или несколько пробелов число T<sub>i</sub> — время в секундах, которое папа Карло будет тратить на забивание одного гвоздика, если он перед этим увидит по телевизору эту передачу (1 ≤ T<sub>i</sub> ≤ 32400).Передачи записаны в хронологическом порядке. Первая передача всегда начинается в 09:00:00. Можно считать, что последняя передача заканчивается в 18:00:00.

### Формат вывода

В первую строку выходного файла требуется вывести максимальное количество гвоздиков, которое папа Карло успеет вбить за рабочий день.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 2<br>09:00:00 3600<br>14:00:00 3600 | 8 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 4<br>09:00:00 1800<br>12:59:31 10<br>13:45:23 1800<br>15:00:00 3600 | 14 |

```python
def count_dp(dp, time_, time_in_secinds):
    for i in range(0, time_in_secinds):
        # Либо ждем одну секунду,
        # тогда в следующую секунду забьем тоже самое количество гвоздей, что есть сейчас
        # Обязательно берем максимум, так как к тому моменту уже могло быть забито больше гвоздей, чем есть сейчас
        dp[i + 1] = max(dp[i], dp[i + 1])
        if i + time_[i] <= time_in_secinds:
            # Либо к моменту времени "текущая секунда + время на забивание гвоздя" забиваем +1 гвоздь к текущему количеству
            # Снова берем максимум, так как может там уже забито больше, чем есть сейчас + 1
            dp[i + time_[i]] = max(dp[i] + 1, dp[i + time_[i]])

def main():
    number_of_tv_shows = int(input())
    prev_time_per_nail = int(input().split()[1])
    prev = 0
    # Временная шкала из 9 часов в секундах. На каждом месте - время для забивания гвоздя
    time_ = [0 for _ in range(32400)]
    for _ in range(number_of_tv_shows - 1):
        start, time_per_nail = input().split()
        temp = list(map(int, start.split(':')))
        start = 3600 * temp[0] + 60 * temp[1] + temp[2] - 32400
        for i in range(prev, start):
            time_[i] = prev_time_per_nail
        prev = start
        prev_time_per_nail = int(time_per_nail)
    for i in range(prev, 32400):
        time_[i] = prev_time_per_nail

    # Забиваем до обеденного перерыва - 13:00 в секундах
    dp = [0 for _ in range(14401)]
    count_dp(dp, time_[0:14400], 14400)
    # Запоминаем максимум, чтобы перезаписывать ненужные данные в тот же массив
    dp[0] = dp[-1]
    # Забиваем после обеденного перерыва и до ухода домой
    count_dp(dp, time_[18000:], 14400)
    print(dp[-1])
```

## 25

Петя и Маша играют в увлекательную игру. Маша загадывает число от 1 до n, записывает его на чистый тетрадный лист, кладёт в конверт и запечатывает. После этого Петя пытается это число отгадать. Он может задавать любые вопросы про это число: «Верно ли, что это число равно трем?», «Верно ли, что это число – число Фибоначчи?», «Верно ли, что это число простое?» и так далее. Получив ответ «да», Петя отдает Маше a конфет, а в случае ответа «нет» — b конфет.
В какой-то момент Петя произносит сакраментальную фразу: «Я знаю, что это за число». После этого они распечатывают конверт в присутствии свидетелей, убеждаются в Петиной правоте, и Маша получает внушительную порцию конфет, а Петя — моральное удовлетворение.
Петя очень любит играть в эту игру, но его кондитерские запасы ограничены. Поэтому Петя хочет выяснить, какое минимальное количество конфет может ему потребоваться, чтобы отгадать Машино число в худшем случае. Помогите Пете найти указанный минимум.

### Формат ввода

Входной файл содержит три целых числа: n (1 ≤ n ≤ 1000), a и b (0 ≤ a,b ≤ 10<sup>6</sup>)

### Формат вывода

Выведите одно число — минимальное количество конфет, которое должен иметь Петя, чтобы отгадать Машино число в худшем случае.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 8 1 1 | 3 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 10 5 0 | 5 |

<i>Example 3:</i>

| In  | Out |
|:----|:---:|
| 7 0 2 | 2 |

```python
def main():
    # Спрашиваем, больше (или меньше, не имеет значения), чем какое-то К. Если получили ответ да, искать надо на отрезке от К до N, иначе от 0 до К. В худшем случае получим максимум из ответов + ответ на вопрос про соответствующую половину интервала. Начинаем с числа 2, для одгого сразу даем ответ.
    # Почти бинарный поиск, но отличается цена вопроса, поэтому его использовать нельзя, так что остается ручная проверка в цикле
    upperbound, a, b = map(int, input().split())
    dp = [0 for _ in range(upperbound + 1)]
    for i in range(2, upperbound + 1):
        min_ = float('inf')
        for k in range(1, i):
            min_ = min(min_, max(dp[k] + b, dp[i - k] + a))
        dp[i] = min_
    print(dp[-1])
```