## 21

По данному числу N определите количество последовательностей из нулей и единиц длины N, в которых никакие три единицы не стоят рядом.

### Формат ввода

Во входном файле написано натуральное число N, не превосходящее 35.

### Формат вывода

Выведите количество искомых последовательностей. Гарантируется, что ответ не превосходит 2<sup>31</sup>-1.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 1 | 2 |

```python
# К любой заведомо проверенной последовательности в конец можно приписать 0, 01, 011 и НЕ получить подряд стоящие 111. 0 приписываем к последовательности длины i - 1, "01" - i - 2, "011" - i - 3.
# Очередной элемент динамики - сумма трех предыдущих.
def main():
    number = int(input())
    dp = [0, 2, 4, 7]
    for i in range(4, number + 1):
        j = i % 4
        new_value = dp[j - 1] + dp[j - 2] + dp[j - 3]
        dp[j] = new_value
    print(dp[number % 4])
```

## 22

У одного из студентов в комнате живёт кузнечик, который очень любит прыгать по клетчатой одномерной доске. Длина доски — N клеток. К его сожалению, он умеет прыгать только на 1, 2, …, k клеток вперёд.
Однажды студентам стало интересно, сколькими способами кузнечик может допрыгать из первой клетки до последней. Помогите им ответить на этот вопрос.

### Формат ввода

В первой и единственной строке входного файла записано два целых числа — N и k (1 ≤ N ≤ 30, 1 ≤ k ≤ 10).

### Формат вывода

Выведите одно число — количество способов, которыми кузнечик может допрыгать из первой клетки до последней.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 8 2 | 21 |

```python
def main():
    length, jump_distance = map(int, input().split())
    dp = [1, 1, 2]
    for i in range(2, jump_distance):
        dp.append(dp[i] * 2)
    # Уменьшить изначальный массив, если дистанция прыжка меньше 2. Нужно для колцевого буфера
    dp = dp[:jump_distance + 1]
    j = jump_distance
    for _ in range(jump_distance + 1, length):
        # Так как дальше определенного расстояния кузнечик не прыгнет,
        # можно сэкономить место, организовав колцевой буфер из массива
        idx = (j + 1) % (len(dp))
        # Добраться до следующей клетки он может всеми способами, которыми попал в текущую кроме самого первого, а так же из текущей клетки.
        # То есть текущая * 2 - первая, из которой попал в текущую.
        dp[idx] = dp[j] * 2 - dp[idx]
        j = idx
    
    print(dp[(length - 1) % len(dp)])
```

## 23

Имеется калькулятор, который выполняет следующие операции:
* умножить число X на 2;
* умножить число X на 3;
* прибавить к числу X единицу.

Определите, какое наименьшее количество операций требуется, чтобы получить из числа 1 число N.

### Формат ввода

Во входном файле написано натуральное число N, не превосходящее 10<sup>6</sup>.

### Формат вывода

В первой строке выходного файла выведите минимальное количество операций. Во второй строке выведите числа, последовательно получающиеся при выполнении операций. Первое из них должно быть равно 1, а последнее N. Если решений несколько, выведите любое.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 1 | 0<br>1 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 5 | 3<br>1 3 4 5 |

```python
def main():
    number_to_get = int(input())
    cache = [0] * (number_to_get + 1)
    indices = [0, 0]
    for i in range(2, number_to_get + 1):
        v = cache[i - 1]
        # Сначала смотрим на + 1
        index = i - 1
        # Если делится на 2, то можно улучшить
        if i % 2 == 0 and cache[i // 2] < v:
            v = cache[i // 2]
            index = i // 2
        # Если делится на 3, то можно снова улучшить
        if i % 3 == 0 and cache[i // 3] < v:
            v = cache[i // 3]
            index = i // 3
        cache[i] = v + 1
        indices.append(index)
        
    answer = [number_to_get]
    i = indices[-1]
    while i > 0:
        answer.append(i)
        i = indices[i]
    print(len(answer) - 1)
    print(*answer[::-1])
```

## 24

За билетами на премьеру нового мюзикла выстроилась очередь из N человек, каждый из которых хочет купить 1 билет. На всю очередь работала только одна касса, поэтому продажа билетов шла очень медленно, приводя «постояльцев» очереди в отчаяние. Самые сообразительные быстро заметили, что, как правило, несколько билетов в одни руки кассир продаёт быстрее, чем когда эти же билеты продаются по одному. Поэтому они предложили нескольким подряд стоящим людям отдавать деньги первому из них, чтобы он купил билеты на всех.
Однако для борьбы со спекулянтами кассир продавала не более 3-х билетов в одни руки, поэтому договориться таким образом между собой могли лишь 2 или 3 подряд стоящих человека.
Известно, что на продажу i-му человеку из очереди одного билета кассир тратит Ai секунд, на продажу двух билетов — Bi секунд, трех билетов — Ci секунд. Напишите программу, которая подсчитает минимальное время, за которое могли быть обслужены все покупатели.
Обратите внимание, что билеты на группу объединившихся людей всегда покупает первый из них. Также никто в целях ускорения не покупает лишних билетов (то есть билетов, которые никому не нужны).

### Формат ввода

На вход программы поступает сначала число N — количество покупателей в очереди (1 ≤ N ≤ 5000). Далее идет N троек натуральных чисел Ai, Bi, Ci. Каждое из этих чисел не превышает 3600. Люди в очереди нумеруются, начиная от кассы.

### Формат вывода

Требуется вывести одно число — минимальное время в секундах, за которое могли быть обслужены все покупатели.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 5<br>5 10 15<br>2 10 15<br>5 5 5<br>20 20 1<br>20 1 1 | 12 |

```python
def main():
    dp = [0, 0, 0, 0]
    a = [0, 0, 0, 0]
    # "Бесконечнось" времени. В условии числа до 3600 включительно.
    # Таким образом не придется руками считать правильный результат,
    # а такие начальные значения не испортят ответ.
    b = [3601, 3601, 0 ,0]
    c = [3601, 3601, 0, 0]
    with open('input.txt', 'r') as inf:
        number_of_people = int(inf.readline())
        i = 2
        for _ in range(number_of_people):
            time_ = list(map(int, inf.readline().split()))
            a[i] = time_[0]
            b[i] = time_[1]
            c[i] = time_[2]
            one = dp[i - 1] + a[i]
            two = dp[i - 2] + b[i - 1]
            three = dp[i - 3] + c[i - 2]
            dp[i] = (min(one, two, three))
            # Кольцевой буфер
            i = (i + 1) % 4
    print(dp[i - 1])
```

## 25

В дощечке в один ряд вбиты гвоздики. Любые два гвоздика можно соединить ниточкой. Требуется соединить некоторые пары гвоздиков ниточками так, чтобы к каждому гвоздику была привязана хотя бы одна ниточка, а суммарная длина всех ниточек была минимальна.

### Формат ввода

В первой строке входных данных записано число N — количество гвоздиков (2 ≤ N ≤ 100). В следующей строке заданы N чисел — координаты всех гвоздиков (неотрицательные целые числа, не превосходящие 10000).

### Формат вывода

Выведите единственное число — минимальную суммарную длину всех ниточек.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 6<br>3 13 12 4 14 6 | 5 |

```python
def main():
    number_of_nails = int(input())
    bp = [0 for _ in range(number_of_nails)]
    nails_coords = list(map(int, input().split()))
    nails_coords.sort()
    
    length = nails_coords[1] - nails_coords[0]
    if number_of_nails > 2:
        bp[1] = nails_coords[1] - nails_coords[0]
        bp[2] = nails_coords[2] - nails_coords[0]
        for i in range(3, number_of_nails):
            # Каждый гвоздь либо придется связать с предыдущими той же нитью, либо отдельной ниткой с последним.
            # Берем минимум + расстояние от последнего до текущего.
            bp[i] = min(bp[i-1], bp[i-2]) + nails_coords[i] - nails_coords[i-1]
        length = bp[-1]
    print(length)
```