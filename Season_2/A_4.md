Link: <https://contest.yandex.ru/contest/28969>

## A

Палиндром - это строка, которая читается одинаково как справа налево, так и слева направо.

На вход программы поступает набор больших латинских букв (не обязательно различных). Разрешается переставлять буквы, а
также удалять некоторые буквы. Требуется из данных букв по указанным правилам составить палиндром наибольшей длины, а
если таких палиндромов несколько, то выбрать первый из них в алфавитном порядке.

### Формат ввода

В первой строке входных данных содержится число N (1 ≤ N ≤ 100000). Во второй строке задается последовательность из N
больших латинских букв (буквы записаны без пробелов).

### Формат вывода

В единственной строке выходных данных выдайте искомый палиндром.

<i>Example 1:</i>

| In       | Out |
|:---------|:----|
| 3<br>AAB | ABA |

<i>Example 2:</i>

| In           | Out    |
|:-------------|:-------|
| 6<br>QAZQAZ  | AQZZQA |

<i>Example 3:</i>

| In          | Out |
|:------------|:----|
| 6<br>ABCDEF | A   |

```python
def main():
    length = int(input())

    string = input()
    letters = dict()
    for letter in string:
        if letter not in letters:
            letters[letter] = 0
        letters[letter] += 1

    # Случай 1: все буквы встретились четное количество раз
    # Тогда палиндромом максимальной длины минимальным лексикографически будет: буквы в алфавитном порядке, 
    # каждая в количестве равном половине количества вхождений в исходное множество + тоже самое в обратном порядке
    # Случай 2: хотя бы одна буква входит нечетное количетсво раз
    # Тогда нужно нацти букву, вошедшую нечетное количество раз, минимальную лексикографически, затем построить палиндром как в первом случае
    # и поставить найденную букву в количестве одной штуки в центр.
    # Решение для второго случая работает и в первом.

    most_frequent_letter = None
    found = False
    for item in letters.items():
        letter, occurences = item
        if occurences % 2 != 0:
            if not found:
                most_frequent_letter = item
                found = True
            else:
                if letter < most_frequent_letter[0]:
                    most_frequent_letter = item


    palindrome = list()
    for letter in sorted(letters.items(), key=lambda x: x[0]):
        palindrome.append(str(letter[0]) * (letter[1] // 2))
    if found:
        palindrome.append(most_frequent_letter[0])
    for letter in sorted(letters.items(), key=lambda x: x[0], reverse=True):
        palindrome.append(str(letter[0]) * (letter[1] // 2))

    print(''.join(palindrome))
```

## B

Петя разгадывает головоломку, которая устроена следующим образом. Дана квадратная таблица размера NxN, в каждой клетке
которой записана какая-нибудь латинская буква. Кроме того, дан список ключевых слов. Пете нужно, взяв очередное ключевое
слово, найти его в таблице. То есть найти в таблице все буквы этого слова, причем они должны быть расположены так, чтобы
клетка, в которой расположена каждая последующая буква слова, была соседней с клеткой, в которой записана предыдущая
буква (клетки называются соседними, если они имеют общую сторону — то есть соседствуют по вертикали или по горизонтали).
Например, на рисунке ниже показано, как может быть расположено в таблице слово olympiad.

Когда Петя находит слово, он вычеркивает его из таблицы. Использовать уже вычеркнутые буквы в других ключевых словах
нельзя. После того как найдены и вычеркнуты все ключевые слова, в таблице остаются еще несколько букв, из которых Петя
должен составить слово, зашифрованное в головоломке. Помогите Пете в решении этой головоломки, написав программу,
которая по данной таблице и списку ключевых слов выпишет, из каких букв Петя должен сложить слово, то есть какие буквы
останутся в таблице после вычеркивания ключевых слов.

### Формат ввода

В первой строке входного файла записаны два числа N (1 ≤ N ≤ 10) и M (0 ≤ M ≤ 200). Следующие N строк по N заглавных
латинских букв описывают ребус. Следующие M строк содержат слова. Слова состоят только из заглавных латинских букв,
каждое слово не длиннее 200 символов. <b>Гарантируется</b>, что в таблице можно найти и вычеркнуть по описанным выше
правилам все ключевые слова.

### Формат вывода

В единственную строку выходного файла выведите в любом порядке буквы, которые останутся в таблице.

<i>Example 1:</i>

| In                                                                              | Out    |
|:--------------------------------------------------------------------------------|:-------|
| 5 3<br>POLTE<br>RWYMS<br>OAIPT<br>BDANR<br>LEMES<br>OLYMPIAD<br>PROBLEM<br>TEST | AENRSW |

Так как гарантируется, что все слова можно вычеркнуть, то необязательно это моделировать, можно сначала посчитать
количество вхождений каждой буквы в таблице, а затем вычесть суммы вхождений букв во все слова

```python
def main():
    n, m = map(int, input().split())

    # Так как в задаче гарантируется, что слова точно можно вычеркнуть из таблицы,
    # нет необходимости моделировать процесс. Достаточно просто посчитать количество вхождений каждой буквы
    letters = dict()
    for _ in range(n):
        for letter in input():
            if letter not in letters:
                letters[letter] = 0
            letters[letter] += 1

    # А потом уменьшить это число на количество вычеркнутых букв
    for _ in range(m):
        for letter in input():
            letters[letter] -= 1

    # В задаче также сказано, что выводить можно в любом порядке, то есть не надо предварительно сортировать буквы (ключи)
    answer = list()
    for letter, count in letters.items():
        answer.append(letter * count)
    print(''.join(answer))
```

## C

В одной далекой восточной стране до сих пор по пустыням ходят караваны верблюдов, с помощью которых купцы перевозят
пряности, драгоценности и дорогие ткани. Разумеется, основная цель купцов состоит в том, чтобы подороже продать
имеющийся у них товар. Недавно один из караванов прибыл во дворец одного могущественного шаха.

Купцы хотят продать шаху n драгоценных камней, которые они привезли с собой. Для этого они выкладывают их перед шахом в
ряд, после чего шах оценивает эти камни и принимает решение о том, купит он их или нет. Видов драгоценных камней на
Востоке известно не очень много всего 26, поэтому мы будем обозначать виды камней с помощью строчных букв латинского
алфавита. Шах обычно оценивает камни следующим образом. Он заранее определил несколько упорядоченных пар типов камней: (
a1, b1), (a2, b2), ..., (ak, bk). Эти пары он называет красивыми, их множество мы обозначим как P. Теперь представим ряд
камней, которые продают купцы, в виде строки S длины n из строчных букв латинского алфавита. Шах считает число таких
пар (i, j), что 1 ≤ i < j ≤ n, а камни Si и Sj образуют красивую пару, то есть существует такое число 1 ≤ q ≤ k, что Si
= aq и Sj = bq.

Если число таких пар оказывается достаточно большим, то шах покупает все камни. Однако в этот раз купцы привезли
настолько много камней, что шах не может посчитать это число. Поэтому он вызвал своего визиря и поручил ему этот
подсчет. Напишите программу, которая находит ответ на эту задачу.

### Формат ввода

Первая строка входного файла содержит целые числа n и k (1 ≤ n ≤ 100000, 1 ≤ k ≤ 676) число камней, которые привезли
купцы и число пар, которые шах считает красивыми. Вторая строка входного файла содержит строку S, описывающую типы
камней, которые привезли купцы.

Далее следуют k строк, каждая из которых содержит две строчных буквы латинского алфавита и описывает одну из красивых
пар камней.

### Формат вывода

В выходной файл выведите ответ на задачу — количество пар, которое должен найти визирь.

<i>Example 1:</i>

| In                   | Out |
|:---------------------|:----|
| 7 1<br>abacaba<br>aa | 6   |

<i>Example 2:</i>

| In                               | Out |
|:---------------------------------|:----|
| 7 3<br>abacaba<br>ab<br>ac<br>bb | 7   |

```python
def main(number_of_pairs, alphabet):
    total = 0
    alphabet = {a: i for a, i in zip(alphabet, range(len(alphabet)))}
    gift = input().strip()
    pairs = dict()
    # Словарь, где для каждого типа камня хранится список других типов камней, с которыми первый составляет пару
    for _ in range(number_of_pairs):
        pair = input().strip()
        if pair[0] not in pairs:
            pairs[pair[0]] = list()
        pairs[pair[0]].append(alphabet[pair[1]])

    stones_counter = [0] * 26
    stones_counter[alphabet[gift[-1]]] += 1

    # Проход справа налево, считаем количество уже пройденных камней
    for i in range(len(gift) - 2, -1, -1):
        first = gift[i]
        if first in pairs:
            # Для каждого второго типа камня, который составляет пару с первым типом
            for second in pairs[first]:
                # добавляем к ответу количество уже встретившихся камней второго типа,
                # находящихся правее текущего камня первого типа
                total += stones_counter[second]
        # обновляем счетчик только что обработанного типа камней
        stones_counter[alphabet[first]] += 1
    return total


number_of_stones, number_of_pairs = map(int, input().split())
alphabet = 'abcdefghijklmnopqrstuvwxyz'
print(main(number_of_pairs, alphabet))
```

## D 

Саша и Катя учатся в начальной школе. Для изучения арифметики при этом используются карточки, на которых написаны
цифры (на каждой карточке написана ровно одна цифра). Однажды они пришли на урок математики, и Саша, используя все свои
карточки, показал число A, а Катя показала число B. Учитель тогда захотел дать им такую задачу, чтобы ответ на нее
смогли показать и Саша, и Катя, каждый используя только свои карточки. При этом учитель хочет, чтобы искомое число было
максимально возможным.

### Формат ввода

Во входном файле записано два целых неотрицательных числа A и B (каждое число в одной строке). Длина каждого из чисел не
превосходит 100 000 цифр.

### Формат вывода

Выведите одно число — максимальное целое число, которое можно составить используя как цифры первого числа, так и цифры
второго числа. Если же ни одного такого числа составить нельзя, выведите -1.

<i>Example 1:</i>

| In               | Out  |
|:-----------------|:-----|
| 280138<br>798081 | 8810 |

<i>Example 2:</i>

| In         | Out |
|:-----------|:----|
| 123<br>456 | -1  |

```python
def count_digits(string):
    digits = [0] * 10
    for d in string:
        digits[int(d)] += 1
    return digits


def main():
    alexandr = input()
    kate = input()

    a_digits = count_digits(alexandr)
    k_digits = count_digits(kate)  

    # Идем с 9 до 1 и добавляем минимальное количество из обоих наборов цифр
    # если эти цифры, конечно, есть
    answer = list()
    for digit in range(9, 0, -1):
        temp = min(a_digits[digit], k_digits[digit])
        if temp:
            answer.append(str(digit) * temp)

    zeros = min(a_digits[0], k_digits[0])
    # Если цифр кроме нуля не было совсем
    if len(answer) == 0:
        # то одного нуля в ответе хватит
        if zeros >= 1:
            answer.append('0')
        # если не было и нулей, то нельзя составить число
        else:
            answer.append('-1')
    # иначе добавить нули по аналогии с остальными цифрами
    else:
        answer.append('0' * zeros)

    print(''.join(answer))
```

## E

На далекой планете Тау Кита есть непонятные нам обычаи. Например, таукитяне очень необычно для землян выбирают имена
своим детям. Родители так выбирают имя ребенку, чтобы оно могло быть получено как удалением некоторого набора букв из
имени отца, так и удалением некоторого набора букв из имени матери. Например, если отца зовут «abacaba», а мать —
«bbccaa», то их ребенок может носить имена «a», «bba», «bcaa», но не может носить имена «aaa», «ab» или «bbc». Возможно,
что имя ребенка совпадает с именем отца и/или матери, если оно может быть получено из имени другого родителя удалением
нескольких (возможно, ни одной) букв.

Пусть отец по имени X и мать по имени Y выбирают имя своему новорожденному ребенку. Так как в таукитянских школах
учеников часто вызывают к доске в лексикографическом порядке имен учеников, то есть в порядке следования имен в словаре,
то они хотят выбрать своему ребенку такое имя, чтобы оно лексикографически следовало как можно позже.

Формально, строка S лексикографически больше строки T, если выполняется одно из двух условий: строка T получается из S
удалением одной или более букв с конца строки S; первые (i - 1) символов строк T и S не различаются, а буква в i-й
позиции строки T следует в алфавите раньше буквы в i-й позиции строки S. Требуется написать программу, которая по именам
отца и матери находит лексикографически наибольшее имя для их ребенка.

### Формат ввода

Первая строка входного файла содержит X — имя отца. Вторая строка входного файла содержит Y — имя матери. Каждое имя
состоит из строчных букв латинского алфавита, включает хотя бы одну букву и имеет длину не более 10<sup>5</sup> букв.

### Формат вывода

Выходной файл должен содержать искомое лексикографически наибольшее из возможных имен ребенка. В случае, если
подходящего имени для ребенка не существует, выходной файл должен быть пустым.

<i>Example 1:</i>

| In               | Out |
|:-----------------|:----|
| abcabca<br>abcda | ca  |

<i>Example 2:</i>

| In              | Out  |
|:----------------|:-----|
| ccba<br>accbbaa | ccba |

```python
def count_letters(surname):
    a = dict()
    for c in surname:
        if c not in a:
            a[c] = 0
        a[c] += 1
    return a


def remove_used_symbols(surname, surname_letters, maximum_symbol, count, i):
    """
    Уменьшает счетчик букв, которые были вычеркнуты от начала фамилии (surname)
    до последнего вхождения использованной буквы (maximum_symbol)

    Возвращает индекс первой не вычеркнутой буквы в фамилии
    """
    while count > 0:
        cur_letter = surname[i]
        surname_letters[cur_letter] -= 1
        if cur_letter == maximum_symbol:
            count -= 1
        i += 1
    return i


def fast():
    father = input()
    mother = input()
    # Индекс первой НЕ вычеркнутой буквы
    f = 0
    m = 0

    f_name_letters = count_letters(father)
    m_name_letters = count_letters(mother)

    intersect = sorted(f_name_letters.keys() & m_name_letters.keys())

    answer = list()
    while len(intersect) > 0:
        maximum_symbol = intersect.pop()
        count = min(f_name_letters[maximum_symbol], m_name_letters[maximum_symbol])
        answer.append(maximum_symbol * count)

        f = remove_used_symbols(father, f_name_letters, maximum_symbol, count, f)
        m = remove_used_symbols(mother, m_name_letters, maximum_symbol, count, m)

    print(''.join(answer))


def slow():
    father = input()
    mother = input()

    f_name_letters = count_letters(father)
    m_name_letters = count_letters(mother)
    
    intersect = f_name_letters.keys() & m_name_letters.keys()

    answer = list()
    while len(intersect) > 0:
        # Надо взять лексикографически наибольши символ и добавить его наименьшее среди количества вхождений в обе фамилии раз.
        maximum_symbol = max(intersect)
        count = min(f_name_letters[maximum_symbol], m_name_letters[maximum_symbol])
        answer.append(maximum_symbol * count)

        # Надо заменить использованный символ столько раз, сколько он был использован,
        father = father.replace(maximum_symbol, '*', count)
        mother = mother.replace(maximum_symbol, '*', count)
        # чтобы найти самое правое его вхождение и перейти на следующую за этой позицию
        father = father[father.rfind('*') + 1:]
        mother = mother[mother.rfind('*') + 1:]

        f_name_letters = count_letters(father)
        m_name_letters = count_letters(mother)
        intersect = f_name_letters.keys() & m_name_letters.keys()

    print(''.join(answer))
```
|      | time  | memory |
|------|-------|--------|
| slow | 91ms  | 4.27Mb |
| fast | 127ms | 4.27Mb |