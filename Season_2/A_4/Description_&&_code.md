Link: <https://contest.yandex.ru/contest/28969/enter/>

## A

Палиндром - это строка, которая читается одинаково как справа налево, так и слева направо.

На вход программы поступает набор больших латинских букв (не обязательно различных). Разрешается переставлять буквы, а
также удалять некоторые буквы. Требуется из данных букв по указанным правилам составить палиндром наибольшей длины, а
если таких палиндромов несколько, то выбрать первый из них в алфавитном порядке.

### Формат ввода

В первой строке входных данных содержится число N (1 ≤ N ≤ 100000). Во второй строке задается последовательность из N
больших латинских букв (буквы записаны без пробелов).

### Формат вывода

В единственной строке выходных данных выдайте искомый палиндром.

<i>Example 1:</i>

| In       | Out |
|:---------|:----|
| 3<br>AAB | ABA |

<i>Example 2:</i>

| In           | Out    |
|:-------------|:-------|
| 6<br>QAZQAZ  | AQZZQA |

<i>Example 3:</i>

| In          | Out |
|:------------|:----|
| 6<br>ABCDEF | A   |

```python
def main():
    length = int(input())

    string = input()
    letters = dict()
    for letter in string:
        if letter not in letters:
            letters[letter] = 0
        letters[letter] += 1

    most_frequent_letter = None
    found = False
    for letter in letters.items():
        if letter[1] % 2 != 0:
            if not found:
                most_frequent_letter = letter
                found = True
            else:
                if letter[1] > most_frequent_letter[1] or (
                        letter[1] == most_frequent_letter[1] and letter[0] < most_frequent_letter[0]):
                    most_frequent_letter = letter

    palindrome = list()
    for letter in sorted(letters.items(), key=lambda x: (x[0], x[1])):
        palindrome.append(str(letter[0]) * (letter[1] // 2))
    if found:
        palindrome.append(most_frequent_letter[0])
    for letter in sorted(letters.items(), key=lambda x: (x[0], x[1]), reverse=True):
        palindrome.append(str(letter[0]) * (letter[1] // 2))

    print(''.join(palindrome))
```

## B

Петя разгадывает головоломку, которая устроена следующим образом. Дана квадратная таблица размера NxN, в каждой клетке
которой записана какая-нибудь латинская буква. Кроме того, дан список ключевых слов. Пете нужно, взяв очередное ключевое
слово, найти его в таблице. То есть найти в таблице все буквы этого слова, причем они должны быть расположены так, чтобы
клетка, в которой расположена каждая последующая буква слова, была соседней с клеткой, в которой записана предыдущая
буква (клетки называются соседними, если они имеют общую сторону — то есть соседствуют по вертикали или по горизонтали).
Например, на рисунке ниже показано, как может быть расположено в таблице слово olympiad.

Когда Петя находит слово, он вычеркивает его из таблицы. Использовать уже вычеркнутые буквы в других ключевых словах
нельзя. После того как найдены и вычеркнуты все ключевые слова, в таблице остаются еще несколько букв, из которых Петя
должен составить слово, зашифрованное в головоломке. Помогите Пете в решении этой головоломки, написав программу,
которая по данной таблице и списку ключевых слов выпишет, из каких букв Петя должен сложить слово, то есть какие буквы
останутся в таблице после вычеркивания ключевых слов.

### Формат ввода

В первой строке входного файла записаны два числа N (1 ≤ N ≤ 10) и M (0 ≤ M ≤ 200). Следующие N строк по N заглавных
латинских букв описывают ребус. Следующие M строк содержат слова. Слова состоят только из заглавных латинских букв,
каждое слово не длиннее 200 символов. <b>Гарантируется</b>, что в таблице можно найти и вычеркнуть по описанным выше
правилам все ключевые слова.

### Формат вывода

В единственную строку выходного файла выведите в любом порядке буквы, которые останутся в таблице.

<i>Example 1:</i>

| In                                                                              | Out    |
|:--------------------------------------------------------------------------------|:-------|
| 5 3<br>POLTE<br>RWYMS<br>OAIPT<br>BDANR<br>LEMES<br>OLYMPIAD<br>PROBLEM<br>TEST | AENRSW |

Так как гарантируется, что все слова можно вычеркнуть, то необязательно это моделировать, можно сначала посчитать
количество вхождений каждой буквы в таблице, а затем вычесть суммы вхождений букв во все слова

```python
def main():
    n, m = map(int, input().split())

    letters = dict()
    for _ in range(n):
        for letter in input():
            if letter not in letters:
                letters[letter] = 0
            letters[letter] += 1

    for _ in range(m):
        for letter in input():
            letters[letter] -= 1

    answer = list()
    for letter, count in letters.items():
        answer.append(letter * count)
    print(''.join(answer))
```

## C

В одной далекой восточной стране до сих пор по пустыням ходят караваны верблюдов, с помощью которых купцы перевозят
пряности, драгоценности и дорогие ткани. Разумеется, основная цель купцов состоит в том, чтобы подороже продать
имеющийся у них товар. Недавно один из караванов прибыл во дворец одного могущественного шаха.

Купцы хотят продать шаху n драгоценных камней, которые они привезли с собой. Для этого они выкладывают их перед шахом в
ряд, после чего шах оценивает эти камни и принимает решение о том, купит он их или нет. Видов драгоценных камней на
Востоке известно не очень много всего 26, поэтому мы будем обозначать виды камней с помощью строчных букв латинского
алфавита. Шах обычно оценивает камни следующим образом. Он заранее определил несколько упорядоченных пар типов камней: (
a1, b1), (a2, b2), ..., (ak, bk). Эти пары он называет красивыми, их множество мы обозначим как P. Теперь представим ряд
камней, которые продают купцы, в виде строки S длины n из строчных букв латинского алфавита. Шах считает число таких
пар (i, j), что 1 ≤ i < j ≤ n, а камни Si и Sj образуют красивую пару, то есть существует такое число 1 ≤ q ≤ k, что Si
= aq и Sj = bq.

Если число таких пар оказывается достаточно большим, то шах покупает все камни. Однако в этот раз купцы привезли
настолько много камней, что шах не может посчитать это число. Поэтому он вызвал своего визиря и поручил ему этот
подсчет. Напишите программу, которая находит ответ на эту задачу.

### Формат ввода

Первая строка входного файла содержит целые числа n и k (1 ≤ n ≤ 100000, 1 ≤ k ≤ 676) число камней, которые привезли
купцы и число пар, которые шах считает красивыми. Вторая строка входного файла содержит строку S, описывающую типы
камней, которые привезли купцы.

Далее следуют k строк, каждая из которых содержит две строчных буквы латинского алфавита и описывает одну из красивых
пар камней.

### Формат вывода

В выходной файл выведите ответ на задачу — количество пар, которое должен найти визирь.

<i>Example 1:</i>

| In                   | Out |
|:---------------------|:----|
| 7 1<br>abacaba<br>aa | 6   |

<i>Example 2:</i>

| In                               | Out |
|:---------------------------------|:----|
| 7 3<br>abacaba<br>ab<br>ac<br>bb | 7   |

```python
def slow(number_of_pairs, alphabet):
    """
    O(k * n^2)
    """
    total = 0
    stones = {letter: [] for letter in alphabet}
    i = 0
    for stone in input():
        stones[stone].append(i)
        i += 1

    for _ in range(number_of_pairs):
        a, b = list(input())
        for first in stones[a]:
            second = 0
            flag = True
            while flag and second < len(stones[b]):
                if stones[b][second] > first:
                    total += len(stones[b]) - second
                    flag = False
                second += 1
    return total


def fast(number_of_pairs, alphabet):
    """
    O(n + k) 
    """
    total = 0
    alphabet = {a: i for a, i in zip(alphabet, range(26))}
    gift = input()
    pairs = dict()
    for _ in range(number_of_pairs):
        pair = input()
        if pair[0] not in pairs:
            pairs[pair[0]] = list()
        pairs[pair[0]].append(alphabet[pair[1]])

    stones_counter = [0] * 26
    stones_counter[alphabet[gift[-1]]] += 1

    for i in range(len(gift) - 2, -1, -1):
        first = gift[i]
        if first in pairs:
            for second in pairs[first]:
                total += stones_counter[second]
        stones_counter[alphabet[first]] += 1

    print(total)


def main():
    number_of_stones, number_of_pairs = map(int, input().split())
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    print(fast(number_of_pairs, alphabet))
```

## D 

Саша и Катя учатся в начальной школе. Для изучения арифметики при этом используются карточки, на которых написаны
цифры (на каждой карточке написана ровно одна цифра). Однажды они пришли на урок математики, и Саша, используя все свои
карточки, показал число A, а Катя показала число B. Учитель тогда захотел дать им такую задачу, чтобы ответ на нее
смогли показать и Саша, и Катя, каждый используя только свои карточки. При этом учитель хочет, чтобы искомое число было
максимально возможным.

### Формат ввода

Во входном файле записано два целых неотрицательных числа A и B (каждое число в одной строке). Длина каждого из чисел не
превосходит 100 000 цифр.

### Формат вывода

Выведите одно число — максимальное целое число, которое можно составить используя как цифры первого числа, так и цифры
второго числа. Если же ни одного такого числа составить нельзя, выведите -1.

<i>Example 1:</i>

| In               | Out  |
|:-----------------|:-----|
| 280138<br>798081 | 8810 |

<i>Example 2:</i>

| In         | Out |
|:-----------|:----|
| 123<br>456 | -1  |

```python
def count_digits(string):
    digits = [0] * 10
    for d in string:
        digits[int(d)] += 1
    return digits


def main():
    alexandr = input()
    kate = input()

    a_digits = count_digits(alexandr)
    k_digits = count_digits(kate)  

    answer = list()
    # go up to zero (not inclusive)
    for digit in range(9, 0, -1):
        temp = min(a_digits[digit], k_digits[digit])
        if temp:
            answer.append(str(digit) * temp)

    zeros = min(a_digits[0], k_digits[0])
    # if there is no digits
    if len(answer) == 0:
        # except zeros
        if zeros >= 1:
            # than print only one zero
            answer.append('0')
        else:
            answer.append('-1')
    # else append min number of zeros to the end of answer
    else:
        answer.append('0' * zeros)

    print(''.join(answer))
```

## E

На далекой планете Тау Кита есть непонятные нам обычаи. Например, таукитяне очень необычно для землян выбирают имена
своим детям. Родители так выбирают имя ребенку, чтобы оно могло быть получено как удалением некоторого набора букв из
имени отца, так и удалением некоторого набора букв из имени матери. Например, если отца зовут «abacaba», а мать —
«bbccaa», то их ребенок может носить имена «a», «bba», «bcaa», но не может носить имена «aaa», «ab» или «bbc». Возможно,
что имя ребенка совпадает с именем отца и/или матери, если оно может быть получено из имени другого родителя удалением
нескольких (возможно, ни одной) букв.

Пусть отец по имени X и мать по имени Y выбирают имя своему новорожденному ребенку. Так как в таукитянских школах
учеников часто вызывают к доске в лексикографическом порядке имен учеников, то есть в порядке следования имен в словаре,
то они хотят выбрать своему ребенку такое имя, чтобы оно лексикографически следовало как можно позже.

Формально, строка S лексикографически больше строки T, если выполняется одно из двух условий: строка T получается из S
удалением одной или более букв с конца строки S; первые (i - 1) символов строк T и S не различаются, а буква в i-й
позиции строки T следует в алфавите раньше буквы в i-й позиции строки S. Требуется написать программу, которая по именам
отца и матери находит лексикографически наибольшее имя для их ребенка.

### Формат ввода

Первая строка входного файла содержит X — имя отца. Вторая строка входного файла содержит Y — имя матери. Каждое имя
состоит из строчных букв латинского алфавита, включает хотя бы одну букву и имеет длину не более 10<sup>5</sup> букв.

### Формат вывода

Выходной файл должен содержать искомое лексикографически наибольшее из возможных имен ребенка. В случае, если
подходящего имени для ребенка не существует, выходной файл должен быть пустым.

<i>Example 1:</i>

| In               | Out |
|:-----------------|:----|
| abcabca<br>abcda | ca  |

<i>Example 2:</i>

| In              | Out  |
|:----------------|:-----|
| ccba<br>accbbaa | ccba |

```python
def count_letters(string):
    a = dict()
    for c in string:
        if c not in a:
            a[c] = 0
        a[c] += 1
    return a


def main():
    father = input()
    mother = input()

    f_name_letters = count_letters(father)
    m_name_letters = count_letters(mother)
    intersect = f_name_letters.keys() & m_name_letters.keys()

    answer = list()
    while len(intersect) > 0:
        maximum_symbol = max(intersect)
        count = min(f_name_letters[maximum_symbol], m_name_letters[maximum_symbol])
        answer.append(maximum_symbol * count)

        # Replace used symbol in order to find its right most occurrence and jump to that index + 1
        father = father.replace(maximum_symbol, '*', count)
        mother = mother.replace(maximum_symbol, '*', count)
        father = father[father.rfind('*') + 1:]
        mother = mother[mother.rfind('*') + 1:]

        f_name_letters = count_letters(father)
        m_name_letters = count_letters(mother)
        intersect = f_name_letters.keys() & m_name_letters.keys()

    print(''.join(answer))
```