Link: <https://contest.yandex.ru/contest/28736>

## A

Пусть A — массив, состоящий из N элементов A<sub>1</sub>, ... , A<sub>N</sub>. Обозначим его максимальное и минимальное
значение через max(A) и min(A) соответственно. Вычислим сумму элементов S, S=A<sub>1</sub>+A<sub>2</sub>+…+A<sub>N</sub>
. Заменим каждый элемент массива на разницу S и этого элемента: A<sub>i</sub>:= S - A<sub>i</sub>, 1 <= i <= N. Такое
преобразование массива A назовем операцией Confuse. Напишите программу, которая по массиву B, полученному в результате
K-кратного применения операции Confuse к некоторому массиву A, вычислит разность max(A)-min(A).

### Формат ввода

Первая строка входного файла содержит целые числа N и K, где N — количество элементов массива B (2<=N<=10000), а K —
количество применений операции Confuse к начальному массиву A, 1<=K<=100. Вторая строка файла содержит N элементов
массива B. Элементы массива B — целые числа, принадлежащие диапазону от -2 000 000 000 до 2 000 000 000.

### Формат вывода

Единственная строка выходного файла должна содержать целое число - разность max(A) и min(A).

<i>Example 1:</i>

| In                 | Out |
|--------------------|-----|
| 4 2<br>45 52 47 46 | 7   |

```python
def main():
    array_length, confuse_operations = map(int, input().split())

    array = list(map(int, input().split()))

    # разность максимального и минимального не меняется после применения операции confuse
    max_element = array[0]
    min_element = array[0]
    for element in array:
        if element < min_element:
            min_element = element
        elif element > max_element:
            max_element = element
    print(max_element - min_element)
```

## B

Петя нашел на чердаке старый телеграфный аппарат и приделал к нему хитроумное устройство, которое может печатать на
телеграфной ленте определенное слово (обозначим его X). Петино устройство может напечатать на ленте это слово сколько
угодно раз. Петя может заставить аппарат напечатать на ленте и любое другое сообщение, но для этого ему нужно разобрать
свое хитроумное устройство, и после этого он уже не сможет печатать сообщение X. А самое главное, что напечатать даже
один символ другого сообщения потребует от Пети больше усилий, чем напечатать на ленте слово X с помощью хитроумного
устройства.

Петя хочет сделать так, чтобы всем казалось, что ему по телеграфу пришло сообщение Z. Для этого он может (строго в этой
последовательности):

- сколько угодно раз напечатать сообщение X

- разобрать хитроумное устройство и посимвольно напечатать еще что-нибудь (назовем это Y)

- оторвать и выбросить начало ленты так, чтобы на оставшейся ленте было напечатано в точности сообщение Z

Поскольку набирать отдельные символы сообщения Y довольно сложно, Петя хочет, чтобы в сообщении Y было как можно меньше
символов.

Для лучшего понимания задачи смотрите примеры и пояснения к ним.

### Формат ввода

В первой строке вводится слово X, которое Петя может печатать с помощью хитроумного устройства сколько угодно раз. Во
второй строке вводится сообщение Z, которое хочет получить Петя. Каждое сообщение состоит только из маленьких латинских
букв и имеет длину не более 100 символов.

### Формат вывода

Выведите минимальное по длине сообщение Y, которое Пете придется допечатать вручную.

<i>Example 1:</i>

| In             | Out |
|----------------|-----|
| mama<br>amamam | m   |

<i>Example 2:</i>

| In          | Out  |
|-------------|------|
| ura<br>mura | mura |

<i>Example 3:</i>

| In               | Out  |
|------------------|------|
| computer<br>comp | comp |

<i>Example 4:</i>

| In              | Out |
|-----------------|-----|
| ejudge<br>judge |     |

```python
def main():
    built_in_word = input()
    word_to_print = input()

    # Пытаемся подставить встроенное слово концом к каждой позиции с конца слова, которое нужно напечатать
    type_from = len(word_to_print)
    j = len(built_in_word) - 1
    i = len(word_to_print) - 1
    while i > -1:
        if built_in_word[j] == word_to_print[i]:
            j = (j - 1) % len(built_in_word)
        # Если совпадения заканчиваются, то начинаем сравнение с конца встроенного слова, а указатель откуда надо печатать вручную ставим на текущую позицию требуемого слова
        else:
            j = len(built_in_word) - 1
            type_from = i
            # НО
            # Только что рассмотренная буква может совпадать с последней буквой встроенного слова, 
            # поэтому стоит продолжать сравнение с нее, а не с предшествующей ей: type_from = i + 1 вместо i, i = i вместо i -= 1
            # Однако, если рассмотренная буква не совпадает и с конечной буквой встроенного слова, то получится бесконечный цикл из-за постоянного присвоения i = i.
            # Чтобы этого избежать, нужна вторая проверка текущей проверяемой буквы и последней буквы встроенного слова,
            if built_in_word[j] == word_to_print[i]:
                # в случае успеха которой мы уменьшим допечатываемую руками часть слова, 
                type_from += 1
                # и продолжим сравнение с предпоследней буквы встроенного слова.
                j -= 1
            # В худшем случае это замедлит алгоритм в 2 раза O(n) -> O(2n) так как придется проводить одно и то же сравнение дважды.
        i -= 1
    print(word_to_print[type_from:])
```

## C

Из шахматной доски по границам клеток выпилили связную (не распадающуюся на части) фигуру без дыр. Требуется определить
ее периметр.

### Формат ввода

Сначала вводится число N (1 ≤ N ≤ 64) – количество выпиленных клеток. В следующих N строках вводятся координаты
выпиленных клеток, разделенные пробелом (номер строки и столбца – числа от 1 до 8). Каждая выпиленная клетка указывается
один раз.

### Формат вывода

Выведите одно число – периметр выпиленной фигуры (сторона клетки равна единице).

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 3<br>1 1<br>1 2<br>2 1 | 8   |

<i>Example 2:</i>

| In       | Out |
|----------|-----|
| 1<br>8 8 | 4   |

```python
def add_tuples_element_wise(a, b):
    return a[0] + b[0], a[1] + b[1]


def main():
    squares_number = int(input())
    cut_out_squares = set()
    cross = {(-1, 0), (1, 0), (0, -1), (0, 1)}
    perimetr = 0
    for _ in range(squares_number):
        coordinates = tuple(map(int, input().split()))
        base_increment = 4
        for offset in cross:
            if add_tuples_element_wise(coordinates, offset) in cut_out_squares:
                base_increment -= 2
        perimetr += base_increment
        cut_out_squares.add(coordinates)

    print(perimetr)
```

## D

На столе лежали две одинаковые верёвочки целой положительной длины.

Петя разрезал одну из верёвочек на N частей, каждая из которых имеет целую положительную длину, так что на столе стало
N+1 верёвочек. Затем в комнату зашла Маша и взяла одну из лежащих на столе верёвочек. По длинам оставшихся на столе N
верёвочек определите, какую наименьшую длину может иметь верёвочка, взятая Машей.

### Формат ввода

Первая строка входных данных содержит одно целое число N — количество верёвочек, оставшихся на столе (2 ≤ N ≤ 1000). Во
второй строке содержится N целых чисел l<sub>i</sub> — длины верёвочек (1 ≤ l<sub>i</sub> ≤ 1000).

### Формат вывода

Выведите одно целое число — наименьшую длину, которую может иметь верёвочка, взятая Машей.

<i>Example 1:</i>

| In           | Out |
|--------------|-----|
| 4<br>1 5 2 1 | 1   |

<i>Example 2:</i>

| In            | Out |
|---------------|-----|
| 4<br>5 12 4 3 | 24  |

<i>Example 3:</i>

| In           | Out |
|--------------|-----|
| 4<br>1 3 4 4 | 12  |

```python
def main():
    number_of_ropes = int(input())
    ropes = list(map(int, input().split()))
    sum_length = 0
    max_length = 0

    for rope in ropes:
        if rope > max_length:
            max_length = rope
        sum_length += rope

    if sum_length - max_length < max_length:
        print(max_length - (sum_length - max_length))
    else:
        print(sum_length)
```

## E

Фермер Иван с юности следит за своим газоном. Газон можно считать плоскостью, на которой в каждой точке с целыми
координатами растет один пучок травы.

В одно из воскресений Иван воспользовался газонокосилкой и постриг некоторый прямоугольный участок газона. Стороны этого
участка параллельны осям координат, а две противоположные вершины расположены в точках (x1, y1) и (x2, y2). Следует
отметить, что пучки травы, находящиеся на границе этого прямоугольника, также были пострижены.

Довольный результатом Иван купил и установил на газоне дождевальную установку. Она была размещена в точке с
координатами (x3, y3) и имела радиус действия струи r. Таким образом, установка начала поливать все пучки, расстояние от
которых до точки (x3, y3) не превышало r.

Все было хорошо, но Ивана заинтересовал следующий вопрос: сколько пучков травы оказалось и пострижено, и полито в это
воскресенье?

Требуется написать программу, которая позволит дать ответ на вопрос Ивана.

### Формат ввода

В первой строке входного файла содержатся четыре целых числа x1, y1, x2, y2 (−100 000 ≤ x1 < x2 ≤ 100 000; −100 000 ≤
y1 < y2 ≤ 100 000).

Во второй строке входного файла содержатся три целых числа x3, y3, r (−100 000 ≤ x3, y3 ≤ 100 000; 1 ≤ r ≤ 100 000)

### Формат вывода

В выходной файл необходимо вывести одно целое число — число пучков травы, которые были и пострижены, и политы.

<i>Example :</i>

| In               | Out |
|------------------|-----|
| 0 0 5 4<br>4 0 3 | 14  |

```python
from math import ceil, floor


def main():
    x1, y1, x2, y2 = map(int, input().split())
    x3, y3, r = map(int, input().split())

    total_grass = 0

    # Ищем пересечение круга и прямоугольника по аналогии с пересечением двух прямоугольников
    for y in range(max(y1, y3 - r), min(y2, y3 + r) + 1):
        # Дельта - расстояние от координаты х центра окружности до точки на окружности по горизонтали 
        x_delta = (r ** 2 - (y - y3) ** 2) ** 0.5
        x_min = max(ceil(x3 - x_delta), x1)
        x_max = min(floor(x3 + x_delta), x2)
        if x_max - x_min >= 0:
            total_grass += x_max - x_min + 1

    print(total_grass)
```