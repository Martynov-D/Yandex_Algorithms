Link: <https://contest.yandex.ru/contest/29401>

## A TODO

В городе n автобусных остановок, через которые проходят k кольцевых автобусных маршрутов. Каждый маршрут задается списком номеров остановок, через которые он проходит, i-ый маршрут проходит по остановкам a<sub>i, 1</sub>, a<sub>i, 2</sub>, …, a<sub>i, l<sub>i</sub></sub> (в этом порядке). По маршруту ходит ровно один автобус. В момент времени 0 этот автобус находится на остановке a<sub>i<sub>1</sub></sub>. На то, чтобы доехать до следующей на своем маршруте остановки, автобус тратит ровно одну минуту. Временем стоянки автобуса на остановке можно пренебречь. Все маршруты кольцевые, то есть через минуту после остановки a<sub>i, l<sub>i</sub></sub> автобус оказывается на остановке a<sub>i, 1</sub> и едет по маршруту еще раз.
Несколько человек в этом городе решили покататься на автобусах. При этом каждый из них составил план своего катания. План j-го человека состоит из остановки b<sub>j</sub>, на которой человек начнет свое катание и последовательности чисел c<sub>j, 1</sub>, c<sub>j, 2</sub>, …, c<sub>j, m<sub>j</sub></sub>. Эти числа означают следующее: в момент времени 0 человек придет на остановку b<sub>j</sub> и дождется ближайшего автобуса (если в этот момент какой-то автобус находится на остановке b<sub>j</sub>, человек сядет в него). На этом автобусе он проедет c<sub>j, 1</sub> остановок, после чего выйдет и дождется следующего автобуса на той остановке, где он окажется. На нем он проедет c<sub>j, 2</sub> остановок, снова выйдет и снова дождется следующего автобуса. И так далее. Если в какой-то момент к остановке подъедет сразу несколько автобусов, то человек сядет в автобус с минимальным номером маршрута. Когда человек выходит из автобуса на какой-то остановке, он может уехать с этой остановки не раньше, чем через минуту.
Для каждого человека определите, через сколько минут после начального момента и на какой остановке закончится его катание.

### Формат ввода

Во входном файле записано сначала число n, затем число k. Далее записано k строк, задающих автобусные маршруты. Каждая строка начинается с числа l<sub>i</sub>, задающего длину маршрута, затем идет список остановок, через которые проходит маршрут: a<sub>i, 1</sub>, a<sub>i, 2</sub>, …, a<sub>i, l<sub>i</sub></sub>. Маршрут может несколько раз проходить через одну и ту же остановку.
Далее идет число p – количество людей, и затем p строк, задающих планы людей. Каждая строка содержит сначала числа b<sub>j</sub> – номер начальной остановки и m<sub>j</sub> – количество чисел в последовательности. Затем идут числа c<sub>j, 1</sub>, c<sub>j, 2</sub>, …, c<sub>j, m<sub>j</sub></sub>.
Все числа во входном файле натуральные и не превышают 50.

### Формат вывода

В выходной файл для каждого человека выведите два числа: время в минутах, когда закончится его катание, и номер остановки, на которой это произойдет. Если же человек не сможет реализовать свой план до конца (на какой-либо остановке он не дождется автобуса), выведите для него два нуля.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 6 4<br>4  1 2 3 5<br>2  3 4<br>5  5 2 1 3 2<br>2  4 3<br>3<br>1  4  1 2 3 4<br>2  1  1<br>6  3  1 2 3 | 20 1<br>2 3 <br>0 0 |

```python
# Моделирование для каждого человека поездки. При этом на каждом этапе поездки считать, кто где окажется.
# Накапливать эти данные, чтобы не пришлось потом пересчитывать. Идти индексом по маршруту автобуса. Если длина больше текущего значения времени, то вычитаем остаток от деления длины на время из длины, получаем индекс. Иначе индекс равен остатку от деления времени на длину маршрута.

# сложность nˆ4, где n - максимальное значение каждого данного (то есть 50) ~ 6 250 000 операций

bus_stops, number_of_routes = map(int, input().split())
    routes = list()

    events = list()
    for i in range(number_of_routes):
        temp = list(map(int, input().split()))
        length, route = temp[0], temp[1:]
        for j, stop in zip(range(length), route):
            events.append((j, stop, i))
    events.sort()
    
    number_of_passengers = int(input())
    people = list()
    for i in range(number_of_passengers):
        temp = list(map(int, input().split()))
        first_stop, number_of_stops, stops = temp[0], temp[1], temp[2:]

    print(events)
```

## B TODO

Том Сойер уговорил n своих друзей помочь ему в нелегком деле покраски забора, окружающего дом тетушки Полли. Забор представляет собой k последовательных досок, пронумерованных от 1 до k, причем после k-й доски опять идет первая.
Друзья Тома очень привередливы, i-й друг согласен участвовать в покраске только в том случае, если ему дадут покрасить участок из ровно ai последовательных досок.
Кисточка у Тома только одна, поэтому друзья будут красить по очереди и сразу весь отведенный им отрезок. Тому остается лишь выбрать порядок, в котором приглашать друзей, а также выбрать для каждого желаемое количество последовательных досок.
При этом каждый из друзей Тома готов красить как еще неокрашенную доску забора, так и доску, которую уже покрасил один из его предшественников. Тем не менее, друзья получают больше удовольствия от покраски неокрашенной доски. Том хочет выбрать число x и распределить отрезки забора для покраски таким образом, чтобы каждый из его друзей покрасил хотя бы x неокрашенных досок. Том очень любит своих друзей и хочет, чтобы каждый из них получил от процесса покраски забора максимальное удовольствие, поэтому он пытается максимизировать x.
Помогите Тому понять, сколько радости он сможет доставить своим друзьям.

### Формат ввода

Первая строка входного файла содержит два целых числа n (1 ≤ n ≤ 10<sup>5</sup>) и k (1 ≤ k ≤ 10<sup>9</sup>). Следующая строка содержит n целых чисел - значения a<sub>i</sub> (1 ≤ a<sub>i</sub> ≤ k).

### Формат вывода

Выведите одно число - максимальное возможное значение x.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 2 100<br>5 10 | 5 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 4 10<br>7 8 3 5 | 2 |

```python

```

## C TODO

На плоскости задано N прямоугольников с вершинами в точках с целыми координатами и сторонами, параллельными осям координат. Необходимо найти площадь их объединения.

### Формат ввода

В первой строке входного файла указано число N (0 ≤ N ≤ 1500). В следующих N строках заданы по 4 целых числа x1, y1, x2, y2 — сначала координаты левого нижнего угла прямоугольника, потом правого верхнего (0 ≤ x<sub>1</sub> ≤ x<sub>2</sub> ≤ 10<sup>9</sup>, 0 ≤ y<sub>1</sub> ≤ y<sub>2</sub> ≤ 10<sup>9</sup>). Обратите внимание, что прямоугольники могут вырождаться в отрезки и даже в точки.

### Формат вывода

В выходной файл выведите единственное число — ответ на задачу.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 3<br>1 1 3 5<br>5 2 7 4<br>2 4 6 7 | 23 |

```python
def main():
    with open('input.txt', 'r') as f:
        number_of_rectangles = int(f.readline())
        if number_of_rectangles == 0:
            print(0)
            return
        x_axis = list()
        x1, y1, x2, y2 = map(int, f.readline().split())
        min_y = y1
        max_y = y2
        x_axis.append([x1, y1, y2, 1])
        x_axis.append([x2, y1, y2, -1])
        for _ in range(1, number_of_rectangles):
            x1, y1, x2, y2 = map(int, f.readline().split())
            if y1 < min_y:
                min_y = y1
            if y2 > max_y:
                max_y = y2
            x_axis.append([x1, y1, y2, 1])
            x_axis.append([x2, y1, y2, -1])
    x_axis.sort()
    for i in range(len(x_axis)):
        x_axis[i][1] -= min_y
        x_axis[i][2] -= min_y
    max_y += 1
    
    length = max_y - min_y
    # Переделать вертикаль у в дерево отрезков на массивах.
    # Хранить в ячейке значение и номера ячеек с потомками,
    # а так же число, на которое нужно поменять значения у всех потомков (оно же сигнализирует об изменении).
    # При обновлении сохранять измененеие только в родителе, который покрывает целиком весь отрезок, к которому идет обращение.
    # Когда потребуется обратиться к потомку вершины с висящем изменением, протолкнуть изменение первым потомкам. Если нужное значение ниже,
    # то надо проталкивать изменение дальше обоим потомкам каждой вершины, в которой окажемся на пути.
    y_axis = [0 for _ in range(length)]

    union_area = 0
    zeros = length
    prev_x = x_axis[0][0]
    for x, y1, y2, type_ in x_axis:
        union_area += (length - zeros) * (x - prev_x)
        # Придется менять 
        for y in range(y1, y2):
            if y_axis[y] == 0:
                zeros -= 1
            y_axis[y] += type_
            if y_axis[y] == 0:
                zeros += 1
        prev_x = x
    print(union_area)
```

## D

Недавно Петя занялся изучением древних цивилизаций. Он нашел в энциклопедии даты рождения и гибели N различных древних цивилизаций и теперь хочет узнать о влиянии культуры одних цивилизаций на культуру других.
Петя предположил, что между цивилизациями A и B происходил культурный обмен, если они сосуществовали в течение некоторого ненулевого промежутка времени. Например, если цивилизация A зародилась в 600 году до н.э. и существовала до 400 года до н.э., а цивилизация B зародилась в 450 году до н.э. и существовала до 300 года до н.э., то культура каждой из этих цивилизаций оказывала влияние на развитие другой цивилизации в течение 50 лет. В то же время, если цивилизация C зародилась в 400 году до н.э. и существовала до 50 года до н.э., то она не смогла осуществить культурного обмена с цивилизацией A, в то время как культурный обмен с цивилизацией B продолжался в течение 100 лет.
Теперь для выполнения своих исследований Петя хочет найти такую пару цивилизаций, культурный обмен между которыми имел место на протяжении наименьшего ненулевого промежутка времени. Помогите ему!

### Формат ввода

В первой строке вводится число N – количество цивилизаций, культура которых интересует Петю (1 ≤ N ≤ 100 000). Следующие N строк содержат описание цивилизаций – в каждой строке задаются два целых числа S<sub>i</sub> и E<sub>i</sub> – год зарождения и год гибели соответствующей цивилизации. Все числа не превосходят 109 по абсолютной величине, S<sub>i</sub> < E<sub>i</sub>.

### Формат вывода

Выведите два числа – номера цивилизаций, периоды существования которых имеют наименьшее ненулевое пересечение. Если никакие две цивилизации не пересекаются во времени, выведите единственное число 0.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 3<br>-600 -400<br>-450 -300<br>-400 -50 | 1 2 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 2<br>10 20<br>15 21 | 1 2 |

```python
def main():
    number_of_civilizations = int(input())
    civilizations = list()
    for i in range(number_of_civilizations):
        start, end = map(int, input().split())
        # Чтобы не добавлять лишнюю булеву переменную,
        # сохраняем индексы с разными знаками для начала и конца существования цивилизации
        civilizations.append((start, (i + 1)))
        civilizations.append((end, -(i + 1)))
    civilizations.sort()

    civilizations_alive = set()
    min_difference = civilizations[-1][0] - civilizations[0][0] + 1
    born_time = None
    previous_civilization = 0
    best = None
    # Поддерживаем множество существующих цивилизаций.
    # Также постоянно оьновляем номер последней появившейся цивилизации и время ее появления
    for time_, id_ in civilizations:
        if id_ > 0:
            civilizations_alive.add(id_)
            born_time = time_
            previous_civilization = id_
        # Когда какая-то цивилизация исчезает, пытаемся обновить ответ, но только в случае, когда его можно улучшить.
        # Одна из цивилизаций может существовать во время существования другой (один отрезок целиком лежит в другом).
        # В таком случае, если начало и конец принадлежат одной цивилизации, то надо из множества выбрать случайную цивилизацию,
        # но только если в множестве есть еще что-то коме рассматриваемой исчезающей цивилизации.
        # Если номер последней появившейся цивилизации отличается от номера исчезающей (случай, когда отрезок НЕ лежит внутри другого),
        # просто обновляем ответ.
        else:
            id_ = abs(id_)
            cur_difference = abs(time_ - born_time)
            if cur_difference < min_difference:
                if id_ != previous_civilization:
                    min_difference = cur_difference
                    best = (id_, previous_civilization)
                else:
                    if len(civilizations_alive) > 1:
                        iterator = iter(civilizations_alive)
                        temp = next(iterator)
                        # Так как текущую цивилизацию не удалили, можно случайно вытащить ее
                        if temp == id_:
                            temp = next(iterator)
                        best = (id_, temp)
            civilizations_alive.remove(id_)

    if best is not None:
        print(*best)
    else:
        print(0)
```

## E

На прямой задано N попарно различных отрезков [a<sub>i</sub>, b<sub>i</sub>] (i = 1, 2, ..., N, a<sub>i</sub> < b<sub>i</sub>). Будем говорить, что отрезок номер i непосредственно содержится в отрезке номер j (i ≠ j), если:
1. Он полностью принадлежит j-му (то есть a<sub>j</sub> ≤ a<sub>i</sub> и b<sub>i</sub> ≤ b<sub>j</sub>);
2. Среди заданных N отрезков не найдётся такого отрезка (с номером k), что i-й отрезок принадлежит k-му и k-й принадлежит j-му (здесь i, j и k - различные числа).

Ваша задача - для каждого из данных отрезков найти тот, в котором он непосредственно содержится, либо сообщить, что таких нет. Если данный отрезок непосредственно содержится сразу в нескольких - подходит любой из них.

### Формат ввода

Сначала вводится целое число N (1 ≤ N ≤ 100 000). Далее идут N пар целых чисел a<sub>i</sub>, b<sub>i</sub> (-10<sup>9</sup> ≤ a<sub>i</sub> < b<sub>i</sub> ≤ 10<sup>9</sup>).

### Формат вывода

Выведите N чисел. Число номер i должно быть равно номеру отрезка, в котором непосредственно содержится отрезок номер i, либо 0 - если такого не существует.
Если существует несколько решений, выведите любое.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 4<br>2 3<br>0 4<br>1 6<br>0 5 | 3 4 0 0 |

```python
def main():
    number_of_segments = int(input())
    segments = [0 for _ in range(number_of_segments)]
    for i in range(number_of_segments):
        start, end = map(int, input().split())
        segments[i] = (start, end, i)
    # Сортируем сначала по концу отрезка, потом по началу, но в обратном порядке,
    # чтобы длины увеличивались (начало уменьшается == длина увеличивается)
    segments.sort(key=lambda x: (x[1], -x[0]))

    # Отрезки отсортированы по значению конца, а также от коротких к длинным.
    # Кладем отрезки в стек. Если перед этим в стеке были отрезки, проверяем, не покрывает ли текущий отрезок их целиком.
    # Благодаря сортировке, если текущий отрезок покрывает тот, что в стеке сверху,
    # то отрезок в стеке будет непосредственно содержаться в текущем отрезке.
    # Когда все возможные отрезки были проверены и удалены из стека, кладем текущий отрезок в стек.
    answer = [0 for _ in range(number_of_segments)]
    stack = list()
    for start, end, i in segments:
        while len(stack) > 0 and start <= stack[-1][0]:
            start_, id_ = stack.pop()
            answer[id_] = i + 1
        stack.append((start, i))

    print(*answer)
```