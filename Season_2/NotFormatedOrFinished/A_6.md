link <https://contest.yandex.ru/contest/29189>

## A TODO

Это интерактивная задача.

Егор и Пётр играют в игру «Горячо-Холодно» на двумерной плоскости. В начале игры Егор загадывает точке с неотрицательными целыми координатами, не превышающими 10<sup>9</sup>. После чего Пётр пытается угадать эту точку: на i-м ходу он выбирает некоторую точку с целыми координатами (x<sub>i</sub>, y<sub>i</sub>) и сообщает её Егору. Если эта точка ближе к загаданной, чем предыдущая (x<sub>i - 1</sub>, y<sub>i - 1</sub>), Егор отвечает “1”. В противном случае (в том числе и на самый первый вопрос Петра в начале игры) Егор отвечает “0”.

Когда Пётр считает, что у него достаточно информации, он останавливает игру и сообщает ответ (это действие ходом уже не считается). Если ответ правильный и Пётр сделал не более 500 ходов, Пётр считается победителем. В противном случае выиграл Егор. Пётр просит Вас написать программу, которая гарантированно будет выигрывать у Егора.

Гарантируется, что Егор играет честно и не будет менять координаты загаданной точки в процессе игры. 

### Формат вывода

Когда игрок делает ход, он должен вывести два целых числа от 0 до 10<sup>9</sup>, разделённых пробелом — координаты очередной точки, о которой он спрашивает. Если игрок хочет остановить игру и сообщить ответ, он должен вывести символ 'A', а после него через пробел — два целых числа: x и y - координаты загаданной точки, после чего завершить выполнение программы.

После каждого вывода вы обязаны выводить один символ перевода строки, делать команду flush, очищая поток вывода, и считывать ответ. Если ваша программа получит на стандартный вход EOF, она обязана завершить выполнение. В противном случае возможно получение ошибки TimeLimitExceeded.

На каждый ход программа жюри выводит '1' в случае, когда названная программой-игроком точка ближе к загаданной, чем предыдущая, и '0' в противном случае (то есть когда названная точка не ближе предыдущей или предыдущей точки названо не было, то есть если ход первый).

Гарантируется, что координаты загаданной точки целые, неотрицательные и не превосходят 10<sup>9</sup>. 

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 1 1<br>0 0<br>20 20<br>20 20<br>17 239<br>17 240<br>A 17 239 | 0<br>0<br>1<br>0<br>1<br>0 |

```python

```

## B

В одной театральной кассе есть в продаже билеты любой стоимости, выражающейся натуральным числом. При покупке билетов по цене за билет от A до B рублей включительно нужно дополнительно оплатить сервисный сбор в размере C процентов от номинальной стоимости билетов (сервисный сбор не обязательно выражается целым числом рублей, но всегда выражается целым числом копеек). При покупке билетов стоимостью менее A рублей за билет, а также более B рублей за билет, сервисный сбор не берется.

У вас есть X рублей и вам нужно K билетов одинаковой цены (цена обязательно должна выражаться натуральным числом рублей, 0 не считается натуральным). Билеты какого самого дорогого номинала вы можете себе позволить?

### Формат ввода

Вводятся целые A, B, C, X, K (1 ≤ A ≤ B ≤ 10<sup>9</sup>, 0 ≤ C ≤ 1000, 0 ≤ X ≤ 10<sup>9</sup>, 1 ≤ K ≤ 100 000).

### Формат вывода

Если на имеющиеся деньги невозможно приобрести ни одного билета, выведите 0. Иначе выведите натуральное число – номинальную стоимость приобретённых билетов.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 1 10 0 5 5 | 1 |

<i>Example 2:</i>

| In  | Out |
|:----|:---:|
| 10 100 50 50 5 | 9 |

```python
def check(m, args):
    l, r, percent, money, tickets = args
    if l <= m <= r:
        # Добавляем к цене процент, если цена попала в рамки
        m += ((m * percent) / 100)
    # Проверяем, что можем купить
    return money // m >= tickets


def rBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l + 1) // 2
        if check(m, args):
            l = m
        else:
            r = m - 1
    return l


def main():
    l, r, percent, money, tickets = map(int, input().split())

    # Сначала смотрим на цену билета, учитывая процентный сбор
    answer = rBinSearch(1, money, l, r, percent, money, tickets)

    # Так как при определенной цене + проценту общая стоимость билетов может перевалить за бюджет
    # бинарный поиск изменит правую границу поиска, тем самым отсечет потенциальный больший правильный ответ,
    # который не облагается процентным сбором, но проходит из-за меньшей стоимости, чем дешевый + процент.
    # Поэтому найдем цену, передв в бинарный поиск левую границу равную правой границе процентооблажения + 1
    without_percent = rBinSearch(r + 1, money, l, r, percent, money, tickets)
    # Если такие билеты можно купить, то обновим ответ
    if without_percent * tickets <= money:
        answer = without_percent
    print(answer)
```

## C TODO

Одна Очень Престижная Олимпиада, как и все престижные олимпиады в последнее время, состоит из двух туров - регионального и заключительного. Правила отбора во второй тур (заключительный этап) просты:

1. Призеры олимпиады прошлого года приглашаются на заключительный этап вне зависимости от набранных ими в первом туре баллов.

2. Все участники, набравшие не меньше баллов, чем установленный жюри проходной балл, проходят во второй тур.

3. Если в каком-либо из регионов ни один участник по первым двум правилам во второй тур не прошел, то на заключительный этап приглашается участник из этого региона, набравший в нем максимальное количество баллов (это не касается регионов, от которых участников не было).

На второй тур можно пригласить не более M участников.

Известно, что никакие два участника не набрали одинаковое количество баллов. По информации о результатах первого тура помогите жюри установить минимально возможный проходной балл, при котором все правила отбора будут выполнены.

### Формат ввода

В первой строке входного файла содержатся три целых числа N, M и R - число участников первого тура, максимально возможное число участников второго тура и число регионов, из которых могли быть участники (1 ≤ M ≤ N). Далее в N строках содержатся результаты каждого из участников. Каждая строка состоит из четырех целых чисел. Сначала идет id - уникальный идентификатор участника (1 ≤ id ≤ N), далее номер региона region, в котором данный участник учится (1 ≤ region ≤ R), затем score - число баллов, набранных участником, четвертое число равно 1, если участник является призером олимпиады прошлого года, и 0 - в противном случае.

Гарантируется, что все идентификаторы участников различны, никакие два участника не набрали одинаковое число баллов, и выполнить все правила отбора возможно.

### Формат вывода

Выведите одно число - минимальный проходной балл, который можно установить.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 9 6 5<br>6 1 799 0<br>2 4 995 0<br>1 4 989 1<br>7 2 538 0<br>5 4 984 0<br>8 2 1000 0<br>3 2 998 0<br>4 2 823 1<br>9 1 543 0 | 985 |

```python

```

## D

Скоро новый год и Санта-Клаус уже начал готовить свою волшебную оленью упряжку, на которой он развозит подарки детям. Известно, что упряжку везут несколько волшебных оленей, на каждом из которых едут два эльфа.

Но волшебные олени – строптивые животные, поэтому не любые два эльфа могут ехать на любом олене. А именно, каждый олень характеризуется некоторой строптивостью a<sub>i</sub>, а каждый эльф – темпераментом b<sub>i</sub>. Два эльфа j и k могут ехать на i-м олене в том и только в том случае, если либо b<sub>j</sub> < a<sub>i</sub> < b<sub>k</sub>, либо b<sub>k</sub> < a<sub>i</sub> < b<sub>j</sub>.

Чтобы его появление было максимально зрелищным, Санта-Клаус хочет, чтобы в его упряжке было как можно больше оленей. Про каждого оленя Санта знает его строптивость, а про каждого эльфа – его темперамент.

Помогите Санте выяснить, какое максимальное количество оленей он сможет включить в упряжку, каких оленей ему следует выбрать, и какие эльфы должны на них ехать.

### Формат ввода

В первой строке вводятся два целых числа m и n – количество оленей и эльфов, соответственно (1 ≤ m, n ≤ 100 000).

Вторая строка содержит m целых чисел a<sub>i</sub> – строптивость оленей (0 ≤ a<sub>i</sub> ≤ 10<sup>9</sup>). В третьей строке записаны n целых чисел b<sub>i</sub> – темперамент эльфов (0 ≤ b<sub>i</sub> ≤ 10<sup>9</sup>).

### Формат вывода

В первой строке выведите одно число k – максимальное количество оленей, которое Санта-Клаус может включить в свою упряжку. В следующих k строках выведите по три целых числа: d<sub>i</sub>, e<sub>i, 1</sub>, e<sub>i, 2</sub> – для каждого оленя в упряжке выведите его номер и номера эльфов, которые на нем поедут. Если решений несколько, выведите любое.

И эльфы, и олени пронумерованы, начиная с единицы, в том порядке, в котором они заданы во входных данных.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 4 6<br>2 3 4 5<br>1 3 2 2 5 2 | 2<br>1 1 2<br>2 4 5 |

```python
def check(m, args):
    dears, elves = args
    dear_idx = 0
    santa = list()
    
    # Сопоставляем каждого эльфа из первых "m" второму эльфу из последних "m".
    for left in range(m):
        # При чем сопоставляем первого эльфа из левого блока первому эльфу из правого блока
        right = len(elves) - m + left

        # Пытаемся найти оленя, который встанет между ними. 
        while dear_idx < len(dears) and dears[dear_idx][1] <= elves[left][1]:
            dear_idx += 1
        # Если просмотрели всех оленей, а последний так и не встал между эльфами, то "m" выбран неправильно
        if dear_idx == len(dears) or dears[dear_idx][1] >= elves[right][1]:
            return []
        # Если можно поставить оленя, добавляем пару эльфов + оленя к ответу
        santa.append(f'{dears[dear_idx][0]} {elves[left][0]} {elves[right][0]}')
        dear_idx += 1

    return santa

def rBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l + 1) // 2
        # Возвращается не bool а весь текущий ответ
        santa = check(m, args)
        if len(santa) > 0:
            l = m
        else:
            r = m - 1
    
    # Еще одна проверка, так как последний вызов check() мог быть с уже не подходящим "m".
    # Тогда в santa будет неправильный ответ. Если ответ и так был верным, то он перезапишется самим собой.
    return check(l, args)
    

def main():
    number_of_dears, number_of_elves = map(int, input().split())

    dears = list((i + 1, e) for i, e in enumerate(map(int, input().split())))
    elves = list((i + 1, e) for i, e in enumerate(map(int, input().split())))
    dears.sort(key=lambda x: x[1])
    elves.sort(key=lambda x: x[1])

    l = 0
    r = min(number_of_dears, number_of_elves // 2)

    santa = rBinSearch(l, r, dears, elves)
    print(len(santa))
    print('\n'.join(santa))
```

## E

В одной демократической стране приближаются парламентские выборы. Выборы проходят по следующей схеме: каждый житель страны, достигший восемнадцатилетнего возраста, отдает свой голос за одну из политических партий. После этого партия, которая набрала максимальное количество голосов, считается победившей на выборах и формирует правительство. Если несколько партий набрали одинаковое максимальное количество голосов, то они должны сформировать коалиционное правительство, что обычно приводит к длительным переговорам.

Один бизнесмен решил выгодно вложить свои средства и собрался поддержать на выборах некоторые партии. В результате поддержки он планирует добиться победы одной из этих партий, которая затем сформирует правительство, которое будет действовать в его интересах. При этом возможность формирования коалиционного правительства его не устраивает, поэтому он планирует добиться строгой победы одной из партий.

Чтобы повлиять на исход выборов, бизнесмен собирается выделить деньги на агитационную работу среди жителей страны. Исследование рынка показало, что для того, чтобы один житель сменил свои политические воззрения, требуется потратить одну условную единицу. Кроме того, чтобы i-я партия в случае победы сформировала правительство, которое будет действовать в интересах бизнесмена, необходимо дать лидеру этой партии взятку в размере pi условных единиц. При этом некоторые партии оказались идеологически устойчивыми и не согласны на сотрудничество с бизнесменом ни за какие деньги.

По результатам последних опросов известно, сколько граждан планируют проголосовать за каждую партию перед началом агитационной компании. Помогите бизнесмену выбрать, какую партию следует подкупить, и какое количество граждан придется убедить сменить свои политические воззрения, чтобы выбранная партия победила, учитывая, что бизнесмен хочет потратить на всю операцию минимальное количество денег.

### Формат ввода

В первой строке вводится целое число n – количество партий (1 ≤ n ≤ 10<sup>5</sup>). Следующие n строк описывают партии. Каждая из этих строк содержит по два целых числа: v<sub>i</sub> – количество жителей, которые собираются проголосовать за эту партию перед началом агитационной компании, и p<sub>i</sub> – взятка, которую необходимо дать лидеру партии для того, чтобы сформированное ей в случае победы правительство действовало в интересах бизнесмена (1 ≤ v<sub>i</sub> ≤ 10<sup>6</sup>, 1 ≤ p<sub>i</sub> ≤ 10<sup>6</sup> или p<sub>i</sub> = -1). Если партия является идеологически устойчивой, то p<sub>i</sub> равно -1. Гарантируется, что хотя бы одно p<sub>i</sub> не равно -1.

### Формат вывода

В первой строке выведите минимальную сумму, которую придется потратить бизнесмену. Во второй строке выведите номер партии, лидеру которой следует дать взятку. В третьей строке выведите n целых чисел – количество голосов, которые будут отданы за каждую из партий после осуществления операции. Если оптимальных решений несколько, выведите любое.

<i>Example 1:</i>

| In  | Out |
|:----|:---:|
| 3<br>7 -1<br>2 8<br>1 2 | 6<br>3<br>3 2 5 |

```python
def count_votes(i, parties, suffix_sums, threshold):
    # Ищем первую партию, чье количество избирателей больше или равно пороговому значению
    l = 0
    r = len(parties) - 1
    while l < r:
        m = l + (r - l) // 2
        if parties[m][0] >= threshold:
            r = m
        else:
            l = m + 1

    # Если так и не нашли
    if parties[l][0] < threshold:
        return 0

    # Считаем количество голосов, которое будет куплено,
    # как сумма всех голосов партий от последней до текущей минус площадь прямоугольника
    # (высота - пороговое значение, ширина - расстояние от конца до текущей партии)
    votes = suffix_sums[l] - threshold * (len(parties) - l)
    # Если количество избирателей рассматриваемой партии выше порогового значения,
    # то не учитываем ее в подсчете голосов
    if parties[i][0] >= threshold:
        votes -= (parties[i][0] - threshold)
    return votes


def model(parties, i, suffix_sums):
    # Ищем последнее от минимального к максимальному пороговое значение,
    # при котором еще можно подкупить голоса и выиграть
    l = 0
    r = int(1e6)
    while l < r:
        m = l + (r  - l + 1) // 2
        # Голоса, которые будут куплены
        votes = count_votes(i, parties, suffix_sums, m)
        if votes + parties[i][0] > m:
            l = m
        else:
            r = m - 1
    
    votes = count_votes(i, parties, suffix_sums, l)
    # Голоса, которые стоят выше порогового значения на 2
    cashback = max(0, parties[i][0] + votes - l - 2)
    return votes - cashback, l, cashback


def main():
    with open('input.txt', 'r') as f:
        number_of_parties = int(f.readline())
        # Избиратели, цена подкупа, номер в исходной последовательности
        parties = [[0, 0, i] for i in range(number_of_parties)]
        for i in range(number_of_parties):
            parties[i][0], parties[i][1] = map(int, f.readline().split())
   
    parties.sort()
    # Суффиксные суммы для подсчета голосов выше порогового значения
    suffix_sums = [0] * (number_of_parties)
    suffix_sums[-1] = parties[-1][0]
    for i in range(number_of_parties - 2, -1, -1):
        suffix_sums[i] = suffix_sums[i + 1] + parties[i][0]

    # Для каждой партии ищем пороговое значение, выше которого скупаем все голоса остальных партий.
    # Среди таких партий ищем ту, которую можно подкупить + купить голоса с минимальными вложениями
    min_cost = int(1e12) + 1
    answer = list()
    for i in range(number_of_parties):
        if parties[i][1] != -1:
            # Считаем голоса, пороговое значение, выше которого все скупаем, и голоса,
            # которые можно вернуть и все-равно победить, при этом сэкономив
            cost, threshold, cashback = model(parties, i, suffix_sums)
            if parties[i][1] + cost < min_cost:
                min_cost = parties[i][1] + cost
                answer = [i, cost, threshold, cashback]

    # Финальное распределение голосов
    winner, cost, threshold, cashback = answer
    votes = [0] * number_of_parties
    for i in range(number_of_parties):
        if i == winner:
            votes[parties[i][2]] = str(parties[i][0] + cost)
        elif parties[i][0] <= threshold:
            votes[parties[i][2]] = str(parties[i][0])
        else:
            if cashback > 0:
                votes[parties[i][2]] = str(threshold + 1)
                cashback -= 1
            else:
                votes[parties[i][2]] = str(threshold)

    with open('output.txt', 'w') as f:
        f.write(f'{min_cost}\n')
        # В ответе просят нумерацию с единицы
        f.write(f'{parties[winner][2] + 1}\n')
        f.write(' '.join(votes))
```