Link: <https://contest.yandex.ru/contest/27844>

## A

Реализуйте двоичный поиск в массиве.

### Формат ввода

В первой строке входных данных содержатся натуральные числа N и K (0 < N, K ≤ 10<sup>5</sup>). Во второй строке задаются N элементов первого массива, а в третьей строке – K элементов второго массива. Элементы обоих массивов - целые числа, каждое из которых по модулю не превосходит 10<sup>9</sup>

### Формат вывода

Требуется для каждого из K чисел вывести в отдельную строку "YES", если это число встречается в первом массиве, и "NO" в противном случае. 

<i>Example 1:</i>

| In | Out |
|----|-----|
| 10 10<br>1 61 126 217 2876 6127 39162 98126 712687 1000000000<br>100 6127 1 61 200 -10000 1 217 10000 1000000000 | NO<br>YES<br>YES<br>YES<br>NO<br>NO<br>YES<br>YES<br>NO<br>YES |

<i>Example 2:</i>

| In | Out |
|----|-----|
| 10 10<br>-8 -6 -4 -4 -2 -1 0 2 3 3<br>8 3 -3 -2 2 -1 2 9 -8 0  | NO<br>YES<br>NO<br>YES<br>YES<br>YES<br>YES<br>NO<br>YES<br>YES |

<i>Example 3:</i>

| In | Out |
|----|-----|
| 10 5<br>1 2 3 4 5 6 7 8 9 10<br>-2 0 4 9 12  | NO<br>NO<br>YES<br>YES<br>NO |

```python
def binSearch(array, number):
    l = 0
    r = len(array)
    while l < r:
        m = l + (r - l) // 2
        if array[m] < number:
            l = m + 1
        elif array[m] > number:
            r = m
        else:
            return m


def main():
    # Не используются
    first_length, second_length = input().split()

    first = list(map(int, input().split()))
    second = list(map(int, input().split()))
    # В условии не скзано, отсортированы массивы или нет
    # Сортировка даст n*log(n) затратам по времени
    # Тесты в контесте проходит без сортировки
    first.sort()
    
    for element in second:
        if binSearch(first, element) is not None:
            print("YES")
        else:
            print("NO")
```

## B

Для каждого из чисел второй последовательности найдите ближайшее к нему в первой.

### Формат ввода

В первой строке входных данных содержатся числа N и K (0 < N, K ≤ 10<sup>5</sup> + 1). Во второй строке задаются N чисел первого массива, отсортированного по неубыванию, а в третьей строке – K чисел второго массива. Каждое число в обоих массивах по модулю не превосходит 2*10<sup>9</sup>. 

### Формат вывода

Для каждого из K чисел выведите в отдельную строку число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них. 

<i>Example 1:</i>

| In | Out |
|----|-----|
| 5 5<br>1 3 5 7 9<br>2 4 8 1 6<br> | 1<br>3<br>7<br>1<br>5 |

<i>Example 2:</i>

| In | Out |
|----|-----|
| 6 11<br>1 1 4 4 8 120<br>1 2 3 4 5 6 7 8 63 64 65 | 1<br>1<br>4<br>4<br>4<br>4<br>8<br>8<br>8<br>8<br>120 |

<i>Example 3:</i>

| In | Out |
|----|-----|
| 10 10<br>-5 1 1 3 5 5 8 12 13 16<br>0 3 7 -17 23 11 0 11 15 7 | 1<br>3<br>8<br>-5<br>16<br>12<br>1<br>12<br>16<br>8 |

```python
def lBinSearch(l, r, array, number_to_find):
    while l < r:
        m = l + (r - l) // 2
        if array[m] > number_to_find:
            r = m
        else:
            l = m + 1

    # Если символа не оказалось в массиве,
    # сравниваем первый больший (l) и последний меньший (l - 1).
    # Просят найти ближайший по значению, а если равны, то первый по порядку. Поэтому ≤
    if l > 0 and array[l] != number_to_find and abs(array[l - 1] - number_to_find) <= abs(array[l] - number_to_find):
        return array[l - 1]
    # Если нашли или указатели на самом первом элементе массива,
    # или первый больший ближе по значению последнего меньшего
    else:
        return array[l]


def main():
    n, k = list(map(int, input().split()))

    first = list(map(int, input().split()))
    second = list(map(int, input().split()))

    for number in second:
        print(lBinSearch(0, n - 1, first, number))
```

## C

Когда Петя учился в школе, он часто участвовал в олимпиадах по информатике, математике и физике. Так как он был достаточно способным мальчиком и усердно учился, то на многих из этих олимпиад он получал дипломы. К окончанию школы у него накопилось n дипломов, причём, как оказалось, все они имели одинаковые размеры: w — в ширину и h — в высоту. Сейчас Петя учится в одном из лучших российских университетов и живёт в общежитии со своими одногруппниками. Он решил украсить свою комнату, повесив на одну из стен свои дипломы за школьные олимпиады. Так как к бетонной стене прикрепить дипломы достаточно трудно, то он решил купить специальную доску из пробкового дерева, чтобы прикрепить её к стене, а к ней — дипломы. Для того чтобы эта конструкция выглядела более красиво, Петя хочет, чтобы доска была квадратной и занимала как можно меньше места на стене. Каждый диплом должен быть размещён строго в прямоугольнике размером w на h. Дипломы запрещается поворачивать на 90 градусов. Прямоугольники, соответствующие различным дипломам, не должны иметь общих внутренних точек. Требуется написать программу, которая вычислит минимальный размер стороны доски, которая потребуется Пете для размещения всех своих дипломов. 

### Формат ввода

Входной файл содержит три целых числа: w, h, n (1 ≤ w, h, n ≤ 10<sup>9</sup>).

### Формат вывода

В выходной файл необходимо вывести ответ на поставленную задачу. 

<i>Example 1:</i>

| In | Out |
|----|-----|
| 2 3 10 | 9 |

```python
def check(size, args):
    width, height, number = args
    return (size // width) * (size // height) >= number


def lBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l) // 2
        if check(m, args):
            r = m
        else:
            l = m + 1
    return l


def main():
    width, height, number = list(map(int, input().split()))
    print(lBinSearch(0, min(number * width, number * height), width, height, number))
```

## D

Для освоения Марса требуется построить исследовательскую базу. База должна состоять из n одинаковых модулей, каждый из которых представляет собой прямоугольник.

Каждый модуль представляет собой жилой отсек, который имеет форму прямоугольника размером a на b метров. Для повышения надежности модулей инженеры могут добавить вокруг каждого модуля слой дополнительной защиты. Толщина этого слоя должна составлять целое число метров, и все модули должны иметь одинаковую толщину дополнительной защиты. Модуль с защитой, толщина которой равна d метрам, будет иметь форму прямоугольника размером (a + 2d)(b + 2d) метров.

Все модули должны быть расположены на заранее подготовленном прямоугольном поле размером w*h метров. При этом они должны быть организованы в виде регулярной сетки: их стороны должны быть параллельны сторонам поля, и модули должны быть ориентированы одинаково.

Требуется написать программу, которая по заданным количеству и размеру модулей, а также размеру поля для их размещения, определяет максимальную толщину слоя дополнительной защиты, который можно добавить к каждому модулю.

### Формат ввода

Входной файл содержит пять разделенных пробелами целых чисел: n, a, b, w и h (1 ≤ n, a, b, w, h ≤ 10<sup>18</sup>). Гарантируется, что без дополнительной защиты все модули можно разместить в поселении описанным образом. 

### Формат вывода

Выходной файл должен содержать одно целое число: максимальную возможную толщину дополнительной защиты. Если дополнительную защиту установить не удастся, требуется вывести число 0. 

<i>Example 1:</i>

| In | Out |
|----|-----|
| 1 1 1 1 1 | 0 |

<i>Example 2:</i>

| In | Out |
|----|-----|
| 1 1 1 3 3 | 1 |

```python
def check(size, args):
    a, b, width, height, number = args
    # В отличие от предыдущей задачи уже размеры площадки заданы, а искать надо размеры объекта
    return (width // (a + 2 * size)) * (height // (b + 2 * size)) >= number


def rBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l + 1) // 2
        if check(m, args):
            l = m
        else:
            r = m - 1
    return l


def main():
    number, a, b, width, height = list(map(int, input().split()))
    # Способ решения идентичен предыдущей задаче, только надо найти ответ для вертикально
    # и горизонтально расположенных модулей, а затем выбрать максимум.
    # Второе отличие - искать надо последний подходящий, а не первый.
    print(max(rBinSearch(0, min(height, width), a, b, width, height, number),
          rBinSearch(0, min(height, width), b, a, width, height, number)))
```

## E

В лицее на уроках информатики ответы учеников оцениваются целым числом баллов от 2 до 5 . Итоговая оценка по информатике выставляется как среднее арифметическое оценок на всех уроках, округленное до ближайшего целого числа. Если среднее значение находится ровно посередине между двумя целыми числами, то оценка округляется вверх.

Примеры округления оценок приведены в таблице.

| Оценки на уроках | Среднее арифметическое | Итоговая оценка |
|:----------------:|------------------------|:---------------:|
| 2, 3, 5 | $$ {2 + 3 + 5 \over 3} = 3{1 \over 3} $$ | 3 |
| 3, 3, 4, 4 | $$ {3 + 3 + 4 + 4 \over 4} = 3{1 \over 2} $$ | 4 |
| 5, 5, 5, 3, 5 | $$ {5 + 5 + 5 + 3 + 5 \over 5} = 4{3 \over 5} $$ | 5 |

Все ученики лицея стремятся получить итоговую оценку по информатике не ниже 4 баллов. К сожалению, один из учеников получил на уроках a двоек, b троек и c четверок. Теперь он планирует получить несколько пятерок, причем хочет, чтобы итоговая оценка была не меньше 4 баллов. Ему надо понять, какое минимальное количество пятерок ему необходимо получить, чтобы добиться своей цели.

Требуется написать программу, которая по заданным целым неотрицательные числам a , b и c определяет минимальное количество пятерок, которое необходимо получить ученику, чтобы его итоговая оценка по информатике была не меньше 4 баллов. 

### Формат ввода

Входные данные содержат три строки. Первая строка содержит целое неотрицательное число a , вторая строка содержит целое неотрицательное число b , третья строка содержит целое неотрицательное число c (0 ≤ a, b, c ≤ 10<sup>15</sup>, a + b + c ≥ 1). 

### Формат вывода

Выходные данные должны содержать одно число: минимальное число пятерок, которое необходимо получить ученику, чтобы итоговая оценка была не меньше 4 баллов. 

<i>Example 1:</i>

| In | Out |
|----|-----|
| 2<br>0<br>0 | 2 |

```python
from math import ceil


def check(excellent, args):
    b, s, g = args
    return (2 * b + 3 * s + 4 * g + 5 * excellent) >= 3.5 * (b + s + g + excellent)


def lBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l) // 2
        if check(m, args):
            r = m
        else:
            l = m + 1
    return l


def get_number_of_excellent_marks(b, s, g):
    # (2 * b + 3 * s + 4 * g + 5 * e) / (b + s + g + e) ≥ 3.5
    e = b + (s - g) / 3
    if e < 0:
        return 0
    else:
        return ceil(e)


def main():
    b = int(input())
    s = int(input())
    g = int(input())
    
    print(lBinSearch(0, b + s + g, b, s, g))
    print(get_number_of_excellent_marks(b, s, g))
```

## F

Сегодня утром жюри решило добавить в вариант олимпиады еще одну, Очень Легкую Задачу. Ответственный секретарь Оргкомитета напечатал ее условие в одном экземпляре, и теперь ему нужно до начала олимпиады успеть сделать еще N копий. В его распоряжении имеются два ксерокса, один из которых копирует лист за х секунд, а другой – за y. (Разрешается использовать как один ксерокс, так и оба одновременно. Можно копировать не только с оригинала, но и с копии.) Помогите ему выяснить, какое минимальное время для этого потребуется. 

### Формат ввода

На вход программы поступают три натуральных числа N, x и y, разделенные пробелом (1 ≤ N ≤ 2 × 10<sup>8</sup>, 1 ≤ x, y ≤ 10). 

### Формат вывода

Выведите одно число – минимальное время в секундах, необходимое для получения N копий. 

<i>Example 1:</i>

| In | Out |
|----|-----|
| 4 1 1 | 3 |

<i>Example 2:</i>

| In | Out |
|----|-----|
| 5 1 2 | 4 |


```python
def check(time, args):
    x, y, N = args
    # Количество для быстрого копировального аппарата за все время + 
    # количество для медленного за все время - время печати одного листа быстрым
    return (time // x) + (time - x) // y >= N


def lBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l) // 2
        if check(m, args):
            r = m
        else:
            l = m + 1
    return l


def main():
    N, x, y = list(map(int, input().split()))

    if x > y:
        x, y = y, x
    # В худшем случае медленный аппарат напечатает половину - время на печать быстрым
    print(lBinSearch(0, (N * y) // 2 + x, x, y, N))
```

## G

Городская площадь имеет размер n × m и покрыта квадратной плиткой размером 1 × 1. При плановой замене плитки выяснилось, что новой плитки недостаточно для покрытия всей площади, поэтому было решено покрыть плиткой только дорожку по краю площади, а в центре площади разбить прямоугольную клумбу (см. рисунок к примеру). При этом дорожка должна иметь одинаковую ширину по всем сторонам площади. Определите максимальную ширину дорожки, которую можно выложить из имеющихся плиток. 

### Формат ввода

Первая и вторая строки входных данных содержат по одному числу n и m (3 ≤ n ≤ 2 × 10<sup>9</sup>, 3 ≤ m ≤ 2 × <sup>9</sup>) — размеры площади.

Третья строка содержит количество имеющихся плиток t, 1 ≤ t < n * m.

Обратите внимание, что значение t может быть больше, чем возможное значение 32-битной целочисленной переменной, поэтому необходимо использовать 64-битные числа (тип int64 в языке Pascal, тип long long в C и C++, тип long в Java и C#).

### Формат вывода

Программа должна вывести единственное число — максимальную ширину дорожки, которую можно выложить из имеющихся плиток.

<i>Example :</i>

| In | Out |
|----|-----|
| 6<br>7<br>38 | 2 |

```python
def check(number, args):
    n, m, t = args
    
    # number -> q

    # n * q   n * q
    # 1 1 1 0 1 1 1 (y-2*q)
    # 1 1 1 0 1 1 1 *
    # 1 1 1 0 1 1 1 q
    # 1 1 1   1 1 1
    # 1 1 1 0 1 1 1 (y-2*q)
    # 1 1 1 0 1 1 1 *
    # 1 1 1 0 1 1 1 q
    
    return (2 * n + 2 * m - 4 * number) * number <= t


def rBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l + 1) // 2
        if check(m, args):
            l = m
        else:
            r = m - 1
    return l


def main():
    n = int(input())
    m = int(input())
    t = int(input())

    print(rBinSearch(0, min(n, m) // 2, n, m, t))
```

## H

Дано N отрезков провода длиной L<sub>1</sub>, L<sub>2</sub>, ..., L<sub>N</sub> сантиметров. Требуется с помощью разрезания получить из них K равных отрезков как можно большей длины, выражающейся целым числом сантиметров. Если нельзя получить K отрезков длиной даже 1 см, вывести 0.

### Формат ввода

В первой строке находятся числа N и К. В следующих N строках - L<sub>1</sub>, L<sub>2</sub>, ..., L<sub>N</sub>, по одному числу в строке.

Ограничения: 1 ≤ N, K ≤ 10<sup>4</sup>, 100 ≤ L<sub>i</sub> ≤ 10<sup>7</sup>, все числа целые. 

### Формат вывода

Вывести одно число - полученную длину отрезков.

<i>Example 1:</i>

| In | Out |
|----|-----|
| 4 11<br>802<br>743<br>457<br>539 | 200 |

```python
def check(length, args):
    k, lengths = args

    number_of_ropes = 0

    # Считаем, сколько проводов в итоге получится, если разрезать на отрезки длинной length
    for rope in lengths:
        number_of_ropes += rope // length

    return number_of_ropes >= k  


def rBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l + 1) // 2
        if check(m, args):
            l = m
        else:
            r = m - 1
    return l


def main():
    n, k = list(map(int, input().split()))
    lengths = list()
    for _ in range(n):
        lengths.append(int(input()))

    # В условии ограничение сверху на длину каждой веревки 10^7
    print(rBinSearch(0, int(1e7), k, lengths))
```

## I

В классе учатся N человек. Классный руководитель получил указание направить на субботник R бригад по С человек в каждой.

Все бригады на субботнике будут заниматься переноской бревен. Каждое бревно одновременно несут все члены одной бригады. При этом бревно нести тем удобнее, чем менее различается рост членов этой бригады.

Числом неудобства бригады будем называть разность между ростом самого высокого и ростом самого низкого членов этой бригады (если в бригаде только один человек, то эта разница равна 0). Классный руководитель решил сформировать бригады так, чтобы максимальное из чисел неудобства сформированных бригад было минимально. Помогите ему в этом!

Рассмотрим следующий пример. Пусть в классе 8 человек, рост которых в сантиметрах равен 170, 205, 225, 190, 260, 130, 225, 160, и необходимо сформировать две бригады по три человека в каждой. Тогда одним из вариантов является такой:

1 бригада: люди с ростом 225, 205, 225

2 бригада: люди с ростом 160, 190, 170

При этом число неудобства первой бригады будет равно 20, а число неудобства второй — 30. Максимальное из чисел неудобств будет 30, и это будет наилучший возможный результат.

### Формат ввода

Сначала вводятся натуральные числа N, R и C — количество человек в классе, количество бригад и количество человек в каждой бригаде (1 ≤ R * C ≤ N ≤ 100 000). Далее вводятся N целых чисел — рост каждого из N учеников. Рост ученика — натуральное число, не превышающее 1 000 000 000. 

### Формат вывода

Выведите одно число — наименьше возможное значение максимального числа неудобства сформированных бригад.

<i>Example 1:</i>

| In | Out |
|----|-----|
| 8 2 3<br>170<br>205<br>225<br>190<br>260<br>130<br>225<br>160 | 30 |

```python
def check(m, args):
    minBrigades, brigadeSize, heights = args
    i = 0
    brigades = 0
    # Смотрим, сколько бригад можно собрать с разницей m в росте. 
    while i < len(heights) - brigadeSize + 1:
        # Подставляем крайние значения интервала массива
        # Каждый раз сдвигаем интервал на 1 или на размер бригады
        if heights[i + brigadeSize - 1] - heights[i] <= m:
            brigades += 1
            i += brigadeSize
        else:
            i += 1
    return brigades >= minBrigades


def lBinSearch(l, r, *args):
    while l < r:
        m = l + (r - l) // 2
        if check(m, args):
            r = m
        else:
            l = m + 1
    return l


def main():
    n, r, c = map(int, input().split())

    heights = list()

    for _ in range(n):
        heights.append(int(input()))
    heights.sort()

    print(lBinSearch(0, heights[-1] - heights[0], r, c, heights))
```

```c++
#include <fstream>
#include <vector>
#include <algorithm>


bool check(int m, int minBrigates, int brigateSize, const std::vector<int>& heights)
{
	int i{ 0 };
	int brigades{ 0 };

	while (i < heights.size() - brigateSize + 1)
	{
		if (heights[i + brigateSize - 1] - heights[i] <= m)
		{
			++brigades;
			i += brigateSize;
		}
		else
			++i;
	}
	return brigades >= minBrigates;
}

int lBinSearch(int l, int r, int minBrigates, int brigateSize, const std::vector<int>& heights)
{
	int m{};
	while (l < r)
	{
		m = l + (r - l) / 2;
		if (check(m, minBrigates, brigateSize, heights))
			r = m;
		else
			l = m + 1;
	}

	return l;
}


int main()
{
	std::ifstream inf{ "input.txt" };
	std::ofstream outf("output.txt");

	int n;
	int r;
	int c;

	inf >> n >> r >> c;

	std::vector<int> heights;
	
	int height{};

	while (inf >> height)

		heights.push_back(height);

	std::sort(heights.begin(), heights.end());

	outf << lBinSearch(0, heights.back() - heights[0], r, c, heights);
	
	
	return 0;
}
```

|                | Time   | Memory |
|----------------|--------|--------|
| GCC 12.2 C++20 | 26ms   | 1.09Mb |
| Python 3.9     | 1.542s | 6.41Mb |


## J

Дано N упорядоченных по неубыванию последовательностей целых чисел (т.е. каждый следующий элемент больше либо равен предыдущему), в каждой из последовательностей ровно L элементов. Для каждых двух последовательностей выполняют следующую операцию: объединяют их элементы (в объединенной последовательности каждое число будет идти столько раз, сколько раз оно встречалось суммарно в объединяемых последовательностях), упорядочивают их по неубыванию и смотрят, какой элемент в этой последовательности из 2L элементов окажется на месте номер L (этот элемент называют левой медианой).

Напишите программу, которая для каждой пары последовательностей выведет левую медиану их объединения.

### Формат ввода

Сначала вводятся числа N и L (2 ≤ N ≤ 100, 1 ≤ L ≤ 300). В следующих N строках задаются последовательности. Каждая последовательность состоит из L чисел, по модулю не превышающих 30 000. 

### Формат вывода

В первой строке выведите медиану объединения 1-й и 2-й последовательностей, во второй строке — объединения 1-й и 3-й, и так далее, в (N‑1)-ой строке — объединения 1-й и N-ой последовательностей, далее медиану объединения 2-й и 3-й, 2-й и 4-й, и т.д. до 2-й и N-ой, затем 3-й и 4-й и так далее. В последней строке должна быть выведена медиана объединения (N–1)-й и N-ой последовательностей. 

<i>Example 1:</i>

| In | Out |
|----|-----|
| 3 6<br>1 4 7 10 13 16<br>0 2 5 9 14 20<br>1 7 16 16 21 22  | 7<br>10<br>9 |

```python
def lBinSearch(l, r, array, compareTo):
    while l < r:
        m = l + (r - l) // 2
        if array[m] >= compareTo:
            r = m
        else:
            l = m + 1
    return l


def countLt(array: list, x: int):
    index = lBinSearch(0, len(array) - 1, array, x)
    if array[index] < x:
        return len(array)
    else:
        return index


def countGt(array: list, x: int):
    return len(array) - countLt(array, x + 1)


def answerBinSearch(a: list, b: list):
    l = min(a[0], b[0])
    r = max(a[-1], b[-1])

    while l < r:
        m = l + (r - l) // 2
        # Ищем индекс первого элемента, который будет больше или равен числу m. Индекс == количеству чисел, меньших числа m
        lessThan = countLt(a, m) + countLt(b, m)
        # Ищем индекс первого большего m + 1, вычитаем его из длины, получаем количество нестрого больших
        greaterThan = countGt(a, m) + countGt(b, m)

        # Нашли левую медиану, если выполняется неравенство
        if lessThan <= len(a) - 1 and greaterThan <= len(a):
            return m

        if lessThan > len(a) - 1:
            r = m - 1
        if greaterThan > len(a):
            l = m + 1
    return l


def mergeArrays(a: list, b: list):
    l = 0
    r = 0
    merged_list = [0] * (len(a) + len(b))
    for i in range(len(merged_list)):
        if l != len(a) and (r == len(b) or a[l] <= b[r]):
            merged_list[i] = a[l]
            l += 1
        else:
            merged_list[i] = b[r]
            r += 1
    return merged_list[len(a) - 1]


def main():
    N, L = map(int, input().split())
    sequences = dict()
    for i in range(N):
        sequences[i] = list(map(int, input().split()))

    # Худший случай K = 30 000, N = 100, L = 300
    # O(N^2)
    for i in range(N - 1):
        for j in range(i + 1, N):
            # log(K) * 4 * log(L)
            # ~ 5000 * 16 * 4 * 9 = 2 880 000
            print(answerBinSearch(sequences[i], sequences[j]))

            # 2L
            # ~ 5000 * 2 * 300 = 3 000 000
            print(mergeArrays(sequences[i], sequences[j]))
```

```C++
#include <fstream>
#include <vector>
#include <map>


int lBinSearch(int l, int r, const std::vector<int>& a, int compareTo)
{
	int m{};
	while (l < r)
	{
		m = l + (r - l) / 2;
		if (a[m] >= compareTo)
			r = m;
		else
			l = m + 1;
	}
	return l;
}


int countLt(const std::vector<int>& a, int x)
{
	int index{ lBinSearch(0, a.size(), a, x) };
	if (a[index] < x)
		return a.size();
	else
		return index;
}

int countGt(const std::vector<int>& a, int x)
{
	return a.size() - countLt(a, x + 1);
}


int answerBinSearch(const std::vector<int>& a, const std::vector<int>& b)
{
	int l{ std::min(a[0], b[0]) };
	int r{ std::max(a.back(), b.back()) };

	int m{};
	int lessThan{};
	int greaterThan{};
	while (l < r)
	{
		m = l + (r - l) / 2;
		lessThan = countLt(a, m) + countLt(b, m);
		greaterThan = countGt(a, m) + countGt(b, m);

		if (lessThan <= a.size() - 1 && greaterThan <= a.size())
			return m;
		
		if (lessThan > a.size() - 1)
			r = m - 1;
		if (greaterThan > a.size())
			l = m + 1;
	}
	return l;
}


int mergedArraysMedian(const std::vector<int>& a, const std::vector<int>& b)
{
	int r{ 0 };
	int l{ 0 };

	std::vector<int> c;
	c.resize(a.size() + b.size());

	for (int i{ 0 }; i < c.size(); ++i)
	{
		if (l != a.size() && (r == b.size() || a[l] <= b[r]))
		{
			c[i] = a[l];
			++l;
		}
		else
		{
			c[i] = b[r];
			++r;
		}
	}
	return c[a.size() - 1];
}


int main()
{
	std::ifstream inf{ "input.txt" };
	std::ofstream outf("output.txt");

	int n{};
	int l{};

	inf >> n >> l;

	std::map<int, std::vector<int>> sequences;

	for (int i{ 0 }; i < n; ++i)
	{
		std::vector<int> temp;
		int number{};
		for (int j{ 0 }; j < l; ++j)
		{
			inf >> number;
			temp.push_back(number);
		}
		sequences[i] = temp;
	}

	for (int i{ 0 }; i < n - 1; ++i)
		for (int j{ i + 1 }; j < n; ++j)
            // Решение 1
			outf << answerBinSearch(sequences[i], sequences[j]) << "\n";
            // Решение 2
            outf << mergedArraysMedian(sequences[i], sequences[j]) << "\n";
	
	
	return 0;
}
```

|                | Solution  | Time      | Memory   |
|----------------|-----------|-----------|----------|
| Python 3.9     | BinSearch | 0.733s    | 3.95Mb   |
| Python 3.9     | Merge     | TL 1.005s | 3.95Mb   |
| GCC 12.2 C++20 | BinSearch | 17ms      | 420.00Kb |
| GCC 12.2 C++20 | Merge     | 24ms      | 420.00Kb |

## K

Дано N упорядоченных по неубыванию последовательностей целых чисел (т.е. каждый следующий элемент больше либо равен предыдущему), в каждой из последовательностей ровно L элементов. Для каждых двух последовательностей выполняют следующую операцию: объединяют их элементы (в объединенной последовательности каждое число будет идти столько раз, сколько раз оно встречалось суммарно в объединяемых последовательностях), упорядочивают их по неубыванию и смотрят, какой элемент в этой последовательности из 2L элементов окажется на месте номер L (этот элемент называют левой медианой).

Напишите программу, которая для каждой пары последовательностей выведет левую медиану их объединения.

### Формат ввода

Сначала вводятся числа N и L (2 ≤ N ≤ 200, 1 ≤ L ≤ 50 000). В следующих N строках задаются параметры, определяющие последовательности.

Каждая последовательность определяется пятью целочисленными параметрами: x1, d1, a, c, m. Элементы последовательности вычисляются по следующим формулам: x1 нам задано, а для всех i от 2 до L: xi = xi – 1 + di – 1. Последовательность di определяется следующим образом: d1 нам задано, а для i ≥ 2 di = ((a * di – 1 + c) mod m), где mod – операция получения остатка от деления (a * di – 1 + c) на m.

Для всех последовательностей выполнены следующие ограничения: 1 ≤ m ≤ 40 000, 0 ≤ a < m, 0 ≤ c < m, 0 ≤ d1 < m. Гарантируется, что все члены всех последовательностей по модулю не превышают 10<sup>9</sup>.

### Формат вывода

В первой строке выведите медиану объединения 1-й и 2-й последовательностей, во второй строке — объединения 1-й и 3-й, и так далее, в (N‑1)-ой строке — объединения 1-й и N-ой последовательностей, далее медиану объединения 2-й и 3-й, 2-й и 4-й, и т.д. до 2-й и N-ой, затем 3-й и 4-й и так далее. В последней строке должна быть выведена медиана объединения (N–1)-й и N-ой последовательностей. 

<i>Example 1:</i>

| In | Out |
|----|-----|
| 3 6<br>1 3 1 0 5<br>0 2 1 1 100<br>1 6 8 5 11 | 7<br>10<br>9 |

```python
def lBinSearch(l, r, array, compareTo):
    while l < r:
        m = l + (r - l) // 2
        if array[m] >= compareTo:
            r = m
        else:
            l = m + 1
    return l


def countLt(array: list, x: int):
    index = lBinSearch(0, len(array) - 1, array, x)
    if array[index] < x:
        return len(array)
    else:
        return index


def countGt(array: list, x: int):
    return len(array) - countLt(array, x + 1)


def answerBinSearch(a: list, b: list):
    l = min(a[0], b[0])
    r = max(a[-1], b[-1])

    while l < r:
        m = l + (r - l) // 2
        lessThan = countLt(a, m) + countLt(b, m)
        greaterThan = countGt(a, m) + countGt(b, m)

        if lessThan <= len(a) - 1 and greaterThan <= len(a):
            return m

        if lessThan > len(a) - 1:
            r = m - 1
        if greaterThan > len(a):
            l = m + 1
    return l


def main():
    N, L = map(int, input().split())
    sequences = dict()

    for i in range(N):
        x1, d1, a, c, m = map(int, input().split())

        x = [x1]
        d = [d1]

        for j in range(1, L):
            x.append(x[j - 1] + d[j - 1])
            d.append((a * d[j - 1] + c) % m)

        sequences[i] = x

    for i in range(N - 1):
        for j in range(i + 1, N):
            print(answerBinSearch(sequences[i], sequences[j]))


if __name__ == "__main__":
    main()
```

|                          | Time   | Memory      |
|--------------------------|--------|-------------|
| Python 3.9               | 3.384s | 258.69Mb ML |
| Python 3.9 (PyPy 7.3.11) | 2.646s | 158.57Mb    |
| GCC 12.2 C++20           | 494ms  | 40.43Mb     |