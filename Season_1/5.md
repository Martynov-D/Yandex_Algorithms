Link: <https://contest.yandex.ru/contest/27794>

## A

Глеб обожает шоппинг. Как-то раз он загорелся идеей подобрать себе майку и штаны так, чтобы выглядеть в них максимально
стильно. В понимании Глеба стильность одежды тем больше, чем меньше разница в цвете элементов его одежды.

В наличии имеется N (1 ≤ N ≤ 100 000) маек и M (1 ≤ M ≤ 100 000) штанов, про каждый элемент известен его цвет (целое
число от 1 до 10 000 000). Помогите Глебу выбрать одну майку и одни штаны так, чтобы разница в их цвете была как можно
меньше.

### Формат ввода

Сначала вводится информация о майках: в первой строке целое число N (1 ≤ N ≤ 100 000) и во второй N целых чисел от 1 до
10 000 000 — цвета имеющихся в наличии маек. Гарантируется, что номера цветов идут в возрастающем порядке (в частности,
цвета никаких двух маек не совпадают).

Далее в том же формате идёт описание штанов: их количество M (1 ≤ M ≤ 100 000) и в следующей строке M целых чисел от 1
до 10 000 000 в возрастающем порядке — цвета штанов.

### Формат вывода

Выведите пару неотрицательных чисел — цвет майки и цвет штанов, которые следует выбрать Глебу. Если вариантов выбора
несколько, выведите любой из них.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 2<br>3 4<br>3<br>1 2 3 | 3 3 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 2<br>4 5<br>3<br>1 2 3 | 4 3 |

<i>Example 3:</i>

| In                               | Out |
|----------------------------------|-----|
| 5<br>1 2 3 4 5<br>5<br>1 2 3 4 5 | 1 1 |

```python
def scan(pants, number_of_pants, shirts, number_of_shirts):
    difference = abs(pants[0] - shirts[0])
    best = [pants[0], shirts[0]]
    p = s = 0

    while p < number_of_pants and s < number_of_shirts:
        temp = abs(shirts[s] - pants[p])
        if temp == 0:
            return pants[p], shirts[s]
        if temp < difference:
            best[0] = pants[p]
            best[1] = shirts[s]
            difference = temp
        if pants[p] < shirts[s]:
            p += 1
        else:
            s += 1

    return best


def main():
    number_of_pants = int(input())
    pants = list(map(int, input().split()))

    number_of_shirts = int(input())
    shirts = list(map(int, input().split()))

    # Гарантируется, что номера цветов идут в возрастающем порядке и не совпадают,
    # поэтому сортировать не нужно и внутри функции нет проёверки на равенство

    print(*scan(pants, number_of_pants, shirts, number_of_shirts))
```

## B

Вася очень любит везде искать своё счастливое число K. Каждый день он ходит в школу по улице, вдоль которой припарковано
N машин. Он заинтересовался вопросом, сколько существует наборов машин, стоящих подряд на местах с L до R, что сумма их
номеров равна K. Помогите Васе знать ответ на его вопрос.
Например, если число N=5, K=17, а номера машин равны 17, 7, 10, 7, 10, то существует 4 набора машин:<br>17 (L=1,R=1)
,<br>7, 10 (L=2,R=3),<br>10, 7 (L=3,R=4),<br>7, 10 (L=4,R=5)

### Формат ввода

В первой строке входных данных задаются числа N и K (1 ≤ N ≤ 100 000, 1 ≤ K ≤ 10<sup>9</sup>). Во второй строке
содержится N
чисел, задающих номера машин. Номера машин могут принимать значения от 1 до 999 включительно.

### Формат вывода

Необходимо вывести одно число — количество наборов.

<i>Example 1:</i>

| In                   | Out |
|----------------------|-----|
| 5 17<br>17 7 10 7 10 | 4   |

<i>Example 2:</i>

| In                | Out |
|-------------------|-----|
| 5 10<br>1 2 3 4 1 | 2   |

```python
n, k = list(map(int, input().split()))
cars = list(map(int, input().split()))

l = 0
r = 0
licence_plate_sum = 0
count = 0

while r < n:
    licence_plate_sum += cars[r]
    if licence_plate_sum == k:
        count += 1
        licence_plate_sum -= cars[l]
        l += 1
        r += 1
    elif licence_plate_sum < k:
        r += 1
    elif licence_plate_sum > k:
        licence_plate_sum -= cars[l]
        licence_plate_sum -= cars[r]
        l += 1
print(count)
```

## C

Александр недавно увлекся горным туризмом. Ему уже надоело покорять отдельные горные пики, и он собирается покорить
самую настоящую горную цепь!

Напомним, что Александр живет в плоском мире. Горная цепь состоит из отрезков, соединяющих точки на плоскости, каждая из
которых находится строго правее предыдущей (x-координата следующей точки больше, чем у предыдущей). Трассой на горной
цепи называется её часть между двумя фиксированными концами отрезков.

Участок, на котором при движении по трассе координата y (высота) всегда возрастает, называется подъемом, величиной
подъема называется разность высот между начальной и конечной точками участка.

Туристическая компания предлагает на выбор несколько трасс на одной горной цепи. Александр из-за финансовых трудностей
может выбрать для поездки только одну из этих трасс. Вы решили помочь ему с выбором. Александру важно для каждой трассы
определить суммарную высоту подъемов на ней (т.е. если сначала был подъем на 100м., потом спуск на 50м., а затем снова подъем на 100м., то суммарная высота подъемов будет 100 + 100). Обратите внимание, что трасса может идти как слева-направо, так и
справа-налево.

### Формат ввода

В первой строке входного файла содержится единственное число N — количество точек ломаной, задающей горную цепь (1 ≤ N ≤
30 000). Далее в N строках содержатся описания точек, каждое из которых состоит из двух целых чисел, xi и yi (1 ≤ xi, yi
≤ 30 000).

В следующей строке находится число M — количество трасс (1 ≤ M ≤ 30 000).

Далее в M строках содержатся описания трасс. Каждое описание представляет собой два целых числа, si и fi, они обозначают
номера вершин начала и конца трассы, соответственно (1 ≤ si ≤ N, 1 ≤ fi ≤ N). Начало и конец трассы могут совпадать.

Гарантируется, что во входном файле задана именно горная цепь.

### Формат вывода

Для каждой трассы выведите одно число — суммарную высоту подъемов на данной трассе.

<i>Example 1:</i>

| In                                                           | Out |
|--------------------------------------------------------------|-----|
| 7<br>2 1<br>4 5<br>7 4<br>8 2<br>9 6<br>11 3<br>15 3<br>1<br>2 6 | 4   |

<i>Example 2:</i>

| In                                                                      | Out         |
|-------------------------------------------------------------------------|-------------|
| 6<br>1 1<br>3 2<br>5 6<br>7 2<br>10 4<br>11 1<br>3<br>5 6<br>1 4<br>4 2 | 0<br>5<br>4 |

```python
def get_prefix_sum_forward(edges: list, number_of_edges: int):
    result = [0] * number_of_edges
    for i in range(1, number_of_edges):
        difference = edges[i] - edges[i - 1]
        if difference > 0:
            result[i] = result[i - 1] + difference
        else:
            result[i] = result[i - 1]
    return result


def get_prefix_sum_backward(edges: list, number_of_edges: int):
    result = [0] * number_of_edges
    for i in range(number_of_edges - 2, -1, -1):
        difference = edges[i] - edges[i + 1]
        if difference > 0:
            result[i] = result[i + 1] + difference
        else:
            result[i] = result[i + 1]
    return result


def main():
    number_of_edges = int(input())
    edges = list()

    for _ in range(number_of_edges):
        # Отбрасываем первое значение (координату х),
        # так как гарантируется, что задана горная цепь
        # (координаты в возрастающем порядке)
        edges.append(tuple(map(int, input().split()))[1])

    number_of_routes = int(input())
    routes = list()
    for _ in range(number_of_routes):
        routes.append(tuple(map(int, input().split())))

    prefix_sum_forward = get_prefix_sum_forward(edges, number_of_edges)
    prefix_sum_backward = get_prefix_sum_backward(edges, number_of_edges)

    result = list()
    for start, end in routes:
        # start|end - 1 из-за того, что массив префиксных сумм равен по длине количеству вершин, и первая вершина на нулевом месте
        # если строить его по длине на единицу больше, то не придется каждый раз вычетать из индекса единицу
        if start < end:
            result.append(prefix_sum_forward[end - 1] - prefix_sum_forward[start - 1])
        else:
            result.append(prefix_sum_backward[end - 1] - prefix_sum_backward[start - 1])
    print('\n'.join(result))
```

## D

В центре города Че есть пешеходная улица - одно из самых популярных мест для прогулок жителей города. По этой улице
очень приятно гулять, ведь вдоль улицы расположено n забавных памятников.

Девочке Маше из города Че нравятся два мальчика из ее школы, и она никак не может сделать выбор между ними. Чтобы
принять окончательное решение, она решила назначить обоим мальчикам свидание в одно и то же время. Маша хочет выбрать
два памятника на пешеходной улице, около которых мальчики будут ее ждать. При этом она хочет выбрать такие памятники,
чтобы мальчики не увидели друг друга. Маша знает, что из-за тумана мальчики увидят друг друга только в том случае, если
они будут на расстоянии не более r метров.

Маше заинтересовалась, а сколько способов есть выбрать два различных памятника для организации свиданий.

### Формат ввода

В первой строке входного файла находятся два целых числа n и r (2 ≤ n ≤ 300000, 1 ≤ r ≤ 10<sup>9</sup>) - количество
памятников и максимальное расстояние, на котором мальчики могут увидеть друг друга.

Во второй строке задано n положительных чисел d<sub>1</sub>, …, d<sub>n</sub>, где d<sub>i</sub> - расстояние от i-го
памятника до начала улицы. Все памятники находятся на разном расстоянии от начала улицы. Памятники приведены в порядке
возрастания расстояния от начала улицы (1 ≤ d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n</sub> ≤ 10<sup>9</sup>).

### Формат вывода

Выведите одно число - число способов выбрать два памятника для организации свиданий.

<i>Example 1:</i>

| In             | Out |
|----------------|-----|
| 4 4<br>1 3 5 8 | 2   |

```python
# Обычная задача на поиск количества пар чисел в отсортированной последовательности,
# сумма которых будет больше заданного значения
def main():
    number_of_monuments, view_range = list(map(int, input().split()))
    distances = list(map(int, input().split()))

    count = 0
    r = 1

    for l in range(number_of_monuments):
        while r < number_of_monuments and distances[r] - distances[l] <= view_range:
            r += 1
        count += number_of_monuments - r
    print(count)
```

## E

В парке города Питсбурга есть чудесная аллея, состоящая из N посаженных в один ряд деревьев, каждое одного из K сортов. В связи с тем, что Питсбург принимает открытый чемпионат Байтландии по программированию, было решено построить огромную арену для проведения соревнований. Так, согласно этому плану вся аллея подлежала вырубке. Однако министерство деревьев и кустов воспротивилось этому решению, и потребовало оставить некоторые из деревьев в покое. Согласно новому плану строительства все деревья, которые не будут вырублены, должны образовывать один непрерывный отрезок, являющийся подотрезком исходного. Каждого из K видов деревьев требуется сохранить хотя бы по одному экземпляру. На вас возложена задача найти отрезок наименьшей длины, удовлетворяющий указанным ограничениям.

### Формат ввода

В первой строке входного файла находятся два числа N и K (1 ≤ N, K ≤ 250000). Во второй строке входного файла следуют N чисел (разделенных пробелами), i-ое число второй строки задает цвет i-ого слева дерева в аллее. Гарантируется, что присутствует хотя бы одно дерево каждого цвета

### Формат вывода

В выходной файл выведите два числа, координаты левого и правого концов отрезка минимальной длины, удовлетворяющего условию. Если оптимальных ответов несколько, выведите любой.

<i>Example 1:</i>

| In  | Out |
|-----|-----|
| 5 3<br>1 2 1 3 2 | 2 4 |

<i>Example 2:</i>

| In  | Out |
|-----|-----|
| 6 4<br>2 4 2 3 3 1 | 2 6 |

```python
def main():
    number_of_trees, number_of_species = map(int, input().split())
    trees = list(map(int, input().split()))

    # В выводе используется индексация с единицы, поэтому в best 1 и len(trees)
    best = [1, number_of_trees] + 1

    l = r = 0
    unique_trees = dict()
    unique_trees = [0] * number_of_trees
    
    while r < number_of_trees:
        cur_tree = trees[r]

        if cur_tree not in unique_trees:
            unique_trees[cur_tree] = 0
        unique_trees[cur_tree] += 1

        # Когда найдем интервал, содержащий все виды деревьев
        if len(unique_trees) == number_of_species:
            cur_tree = trees[l]
            # Надо попробовать подвинуть левую границу,
            # так как каждого вида дерева в найденном интервале может быть несколько штук
            while unique_trees[cur_tree] > 1:
                unique_trees[cur_tree] -= 1
                l += 1
                cur_tree = trees[l]
            # Когда хотя бы один из видов будет в единственном экземпляре, сравниваем текущий результат с лучшим
            if r - l < best[1] - best[0]:
                # Индексация в ответе начинается с единицы, поэтому оба числа + 1
                best = (l + 1, r + 1)
        r += 1
    print(*best)
```

## F

При реализации проекта «Умная школа» было решено в каждый учебный класс выбранной для этого школы установить по кондиционеру нового поколения для автоматического охлаждения и вентиляции воздуха. По проекту в каждом классе должен быть установлен только один кондиционер и мощность кондиционера должна быть достаточной для размеров класса. Чем больше класс, тем мощнее должен быть кондиционер.

Все классы школы пронумерованы последовательно от 1 до n. Известно, что для каждого класса с номером i, требуется ровно один кондиционер, мощность которого больше или равна ai ватт.

Администрации школы предоставили список из m различных моделей кондиционеров, которые можно закупить. Для каждой модели кондиционера известна его мощность и стоимость. Требуется написать программу, которая определит, за какую минимальную суммарную стоимость кондиционеров можно оснастить все классы школы.

### Формат ввода

Первая строка входного файла содержит одно целое число n (1 ≤ n ≤ 50 000) количество классов в школе.

Вторая строка содержит n целых чисел ai (1 ≤ ai ≤ 1000) — минимальная мощность кондиционера в ваттах, который можно установить в классе с номером i.

Третья строка содержит одно целое число m (1 ≤ m ≤ 50 000) — количество предложенных моделей кондиционеров.

Далее, в каждой из m строк содержится пара целых чисел bj и cj (1 ≤ bj ≤ 1000, 1 ≤ cj ≤ 1000) мощность в ваттах j-й модели кондиционера и его цена в рублях соответственно.

### Формат вывода

Выходной файл должен содержать одно число минимальную суммарную стоимость кондиционеров в рублях. Гарантируется, что хотя бы один корректный выбор кондиционеров существует, и во всех классах можно установить подходящий кондиционер.

<i>Example 1:</i>

| In  | Out |
|---------------------------|------|
| 1<br>800<br>1<br>800 1000 | 1000 |

<i>Example 2:</i>

| In  | Out |
|-----------------------------------------------|-----|
| 3<br>1 2 3<br>4<br>1 10<br>1 5<br>10 7<br>2 3 | 13  |

```python
def countPriceN(numberOfRooms: int, rooms: list, conditionerModels: int, conditioners: list):
    # Сортируем по мощности от меньшей к большей
    conditioners = sorted(conditioners, key=lambda conditioner: conditioner[0])
    # Сортируем комнаты в обратном порядке, чтобы воспользоваться for each циклом
    rooms = sorted(rooms, reverse=True)

    result = 0
    # Цены во входных данных не больше 1000, поэтому 1001 как своеобразная бесконечность
    minPrice = 1001
    r = len(conditioners) - 1
    # Для всех комнат от более требовательной к менее требовательной по мощности кондиционера
    for room in rooms:
        # доходим от самого дорогого и мощного до последнего подходящего
        # (то есть минимального по мощности и цене, который подойдет этой комнате)
        while r >= 0 and room <= conditioners[r][0]:
            if conditioners[r][1] < minPrice:
                minPrice = conditioners[r][1]
            r -= 1
        # добавляем цену к общей закупочной
        result += minPrice

    print(result)


def main():
    numberOfRooms = int(input())
    rooms = list(map(int, input().split()))

    conditionerModels = int(input())
    conditioners = list()
    for _ in range(conditionerModels):
        conditioners.append(tuple(map(int, input().split())))

    countPriceN(numberOfRooms, rooms, conditionerModels, conditioners)
```

## G

Андрей работает судьей на чемпионате по гипершашкам. В каждой игре в гипершашки участвует три игрока. По ходу игры каждый из игроков набирает некоторое положительное целое число баллов. Если после окончания игры первый игрок набрал a баллов, второй — b, а третий c, то говорят, что игра закончилась со счетом a:b:c.

Андрей знает, что правила игры гипершашек устроены таким образом, что в результате игры баллы любых двух игроков различаются не более чем в k раз.

После матча Андрей показывает его результат, размещая три карточки с очками игроков на специальном табло. Для этого у него есть набор из n карточек, на которых написаны числа x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>. Чтобы выяснить, насколько он готов к чемпионату, Андрей хочет понять, сколько различных вариантов счета он сможет показать на табло, используя имеющиеся карточки.

Требуется написать программу, которая по числу k и значениям чисел на карточках, которые имеются у Андрея, определяет количество различных вариантов счета, которые Андрей может показать на табло.

### Формат ввода

Первая строка входного файла содержит два целых числа: n и k (3 ≤ n ≤ 10<sup>5</sup>, 1 ≤ k ≤ 10<sup>9</sup>).

Вторая строка входного файла содержит n целых чисел x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub> (1 ≤ x<sub>i</sub> ≤ 10<sup>9</sup>).

### Формат вывода

Выходной файл должен содержать одно целое число — искомое количество различных вариантов счета.

<i>Example 1:</i>

| In  | Out |
|------------------|-----|
| 5 2<br>1 1 2 2 3 | 9   |

```python
def main():
    number_of_cards, max_difference = list(map(int, input().split()))
    card_list = list(map(int, input().split()))
    cards = dict()
    for card in card_list:
        if card not in cards:
            cards[card] = 0
        cards[card] += 1

    unique_cards = sorted(cards.keys())

    r = 0
    duplicates = 0
    result = 0

    for l in range(len(unique_cards)):
        while r < len(unique_cards) and unique_cards[l] * max_difference >= unique_cards[r]:
            if cards[unique_cards[r]] >= 2:
                duplicates += 1
            r += 1
        current_range = r - l
        if cards[unique_cards[l]] >= 2:
            duplicates -= 1
            result += (current_range - 1) * 3
        result += duplicates * 3
        if cards[unique_cards[l]] >= 3:
            result += 1
        # формула суммы арифметической прогрессии
        result += (current_range - 1) * (current_range - 2) * 3

    print(result)
```

## H

В этой задаче Вам требуется найти максимальную по длине подстроку данной строки, такую что каждый символ встречается в ней не более k раз.

### Формат ввода

В первой строке даны два целых числа n и k (1 ≤ n ≤ 100000, 1 ≤ k ≤ n ) , где n – количество символов в строке. Во второй строке n символов – данная строка, состоящая только из строчных латинских букв.

### Формат вывода

В выходной файл выведите два числа – длину искомой подстроки и номер её первого символа. Если решений несколько, выведите любое.

<i>Example 1:</i>

| In  | Out |
|-----|-----|
| 3 1<br>abb | 2 1 |

<i>Example 2:</i>

| In  | Out |
|-----|-----|
| 5 2<br>ababa | 4 1 |

```python
# O(n)
def main():
    length, max_instances = map(int, input().split())
    string = list(input())

    l = 0
    r = 0
    # В выходных данных нумерация с единицы, поэтому best = (длина ноль, начало с единицы)
    best = (0, 1)

    alphabet = dict()

    # Идем по всем элементам
    while r < length:
        cur_letter = string[r]

        # Если еще не встречали эту букву или уже встречали, но вычеркнули все ее вхождения => счетчик равен нулю, то добавляем
        if cur_letter not in alphabet or alphabet[cur_letter]['counter'] == 0:
            alphabet[cur_letter] = {'counter': 0, 'first': r}
        alphabet[cur_letter]['counter'] += 1

        # Если количество вхождений текущей буквы перевалило за лимит "к"
        if alphabet[cur_letter]['counter'] > max_instances:
            # Первым делом, чтобы не потерят потенциальный ответ,
            # нужно сравнить текущий ответ с лучшим, но не включать r-ый символ, поэтому r - l, а не r - l + 1
            if best[0] < (r - l):
                best = (r - l, l + 1)

            # Чтобы поддержать количество вхождений не больше "к", надо убрать все элементы до первого вхождения текущей буквы включительно
            # Меньше нуля счетчики не станут, проверку на это делать не нужно
            while l <= alphabet[cur_letter]['first']:
                alphabet[string[l]]['counter'] -= 1
                l += 1

            # Т.к. предыдущее первое вхождение буквы было вычеркнуто, надо обновить значение переменной first
            # Начиная от нижней границы подстроки ищем новое первое вхождение текущей буквы
            k = l
            while string[k] != cur_letter:
                k += 1
            alphabet[cur_letter]['first'] = k
        # Если же количество вхождений не вышло за рамки, то просто сравниваем текущий ответ с лучшим, 
        # включая текущий элемент, поэтому r - l + 1
        elif best[0] <= (r - l + 1):
            best = (r - l + 1, l + 1)
        r += 1

    print(*best)
```

## I

Студенты одного из вузов спроектировали робота для частичной автоматизации процесса сборки авиационного двигателя.

В процессе сборки двигателя могут встречаться операции 26 типов, которые обозначаются строчными буквами латинского алфавита. Процесс сборки состоит из N операций.

Предполагается использовать робота один раз для выполнения части подряд идущих операций из процесса сборки.

Память робота состоит из K ячеек, каждая из которых содержит одну операцию. Операции выполняются последовательно, начиная с первой, в том порядке, в котором они расположены в памяти. Выполнив последнюю из них, робот продолжает работу с первой. Робота можно остановить после любой операции. Использование робота экономически целесообразно, если он выполнит хотя бы K + 1 операцию.

Требуется написать программу, которая по заданному процессу сборки определит количество экономически целесообразных способов использования робота.

### Формат ввода

В первой строке входного файла записано число K > 0 — количество операций, которые можно записать в память робота.

Вторая строка состоит из N > K строчных латинских букв, обозначающих операции — процесс сборки двигателя. Операции одного и того же типа обозначаются одной и той же буквой. N ≤ 200000

### Формат вывода

Выходной файл должен содержать единственное целое число — количество экономически целесообразных способов использования робота.

<i>Example 1:</i>

| In  | Out |
|-----|-----|
| 2<br>zabacabab | 5   |

<i>Example 2:</i>

| In  | Out |
|-----|-----|
| 2<br>abc | 0  |

```python
def main():
    k = int(input())
    operations = input()
    result = 0
    previous_count_length = 0
    # Ищем операцию, которая совпадает с началом строки записанных в памяти операций
    for i in range(k, len(operations)):
        # Каждый раз либо сбрасываем, если не сопало, либо добавляем единицу и суммируем с результатом
        if operations[i] == operations[i-k]:
            previous_count_length += 1
        else:
            previous_count_length = 0
        # Каждый раз в текущей позиции заканчиваются q экономически целесообразных программы для робота,
        # где q = счетчик. То есть можно выполнить на одну операцию больше, чем длина памяти робота, на две, три ... на q операций больше
        result += previous_count_length
    print(result)
```

## J

Петя достаточно давно занимается в математическом кружке, поэтому он уже успел не только правила выполнения простейших операций, но и такое достаточно сложное понятие как симметрия. Для того, чтобы получше изучить симметрию Петя решил начать с наиболее простых геометрических фигур – треугольников. Он скоро понял, что осевой симметрией обладают так называемые равнобедренные треугольники. Поэтому теперь Петя ищет везде такие треугольники.

Напомним, что треугольник называется равнобедренным, если его площадь положительна, и у него есть хотя бы две равные стороны.

Недавно Петя, зайдя в класс, увидел, что на доске нарисовано n точек. Разумеется, он сразу задумался, сколько существует троек из этих точек, которые являются вершинами равнобедренных треугольников.

Требуется написать программу, решающую указанную задачу.

### Формат ввода

Входной файл содержит целое число n (3 ≤ n ≤ 1500). Каждая из последующих строк содержит по два целых числа – xi и yi – координаты i-ой точки. Координаты точек не превосходят 10<sup>9</sup> по абсолютной величине. Среди заданных точек нет совпадающих.

<i>Example 1:</i>

| In                      | Out |
|-------------------------|-----|
| 3<br>0 0<br>2 2<br>-2 2 | 1   |

<i>Example 2:</i>

| In                            | Out |
|-------------------------------|-----|
| 4<br>0 0<br>1 1<br>1 0<br>0 1 | 4   |

```python
number_of_points = int(input())

points = list()
for _ in range(number_of_points):
    points.append(list(map(int, input().split())))

result = 0

# Перебираем каждую точку. Для простоты можно ее обозначить за "а"
for i in range(number_of_points):
    processed_vectors = set()
    neighbours = list()

    # Для которой считаем расстояние до каждой бругой точки на плоскости (из представленных)
    for j in range(number_of_points):
        x_cord = points[j][0] - points[i][0]
        y_cord = points[j][1] - points[i][1]
        # И добавляем длины в множество. Квадрат не извлекается, чтобы не получить вещественные числа
        neighbours.append(x_cord ** 2 + y_cord ** 2)

        # Если в множестве встречавшихся векторов есть коллинеарный противоположно направленный, то они образуют не треугольник, а прямую.
        if (-x_cord, -y_cord) in processed_vectors:
            # Чтобы в двух указателях не проверять каждый треугольник на вырожденность, просто вычтем единицу из ответа
            result -= 1
        # И в любом случае добавляем вектор в множество встречавшихся ранее
        processed_vectors.add((x_cord, y_cord))

    # Сортируем, чтобы можно было использовать два указателя
    neighbours.sort()
    neighbours_length = len(neighbours)
    r = 0
    # Идем по всем точкам "b" из соседей для "а"
    for l in range(neighbours_length):
        # И находим первую точку, расстояние до которой больше, чем до "b". То есть первую неподходящую точку
        while r < neighbours_length and neighbours[l] == neighbours[r]:
            r += 1
        # Добавляем к результату количество способов взять третью точку "c" для выбранной "b", не учитывая неподходящую (r - l - 1)
        result += r - l - 1
print(result)
```
