Link: <https://contest.yandex.ru/contest/27794/enter/>

## A

Глеб обожает шоппинг. Как-то раз он загорелся идеей подобрать себе майку и штаны так, чтобы выглядеть в них максимально
стильно. В понимании Глеба стильность одежды тем больше, чем меньше разница в цвете элементов его одежды.

В наличии имеется N (1 ≤ N ≤ 100 000) маек и M (1 ≤ M ≤ 100 000) штанов, про каждый элемент известен его цвет (целое
число от 1 до 10 000 000). Помогите Глебу выбрать одну майку и одни штаны так, чтобы разница в их цвете была как можно
меньше.

### Формат ввода

Сначала вводится информация о майках: в первой строке целое число N (1 ≤ N ≤ 100 000) и во второй N целых чисел от 1 до
10 000 000 — цвета имеющихся в наличии маек. Гарантируется, что номера цветов идут в возрастающем порядке (в частности,
цвета никаких двух маек не совпадают).

Далее в том же формате идёт описание штанов: их количество M (1 ≤ M ≤ 100 000) и в следующей строке M целых чисел от 1
до 10 000 000 в возрастающем порядке — цвета штанов.

### Формат вывода

Выведите пару неотрицательных чисел — цвет майки и цвет штанов, которые следует выбрать Глебу. Если вариантов выбора
несколько, выведите любой из них.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 2<br>3 4<br>3<br>1 2 3 | 3 3 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 2<br>4 5<br>3<br>1 2 3 | 4 3 |

<i>Example 3:</i>

| In                               | Out |
|----------------------------------|-----|
| 5<br>1 2 3 4 5<br>5<br>1 2 3 4 5 | 1 1 |

```python
def scan(pants, number_of_pants, shirts, number_of_shirts):
    difference = abs(pants[0] - shirts[0])
    best = [pants[0], shirts[0]]
    p = s = 0

    while p < number_of_pants and s < number_of_shirts:
        temp = abs(shirts[s] - pants[p])
        if temp == 0:
            return pants[p], shirts[s]
        if temp < difference:
            best[0] = pants[p]
            best[1] = shirts[s]
            difference = temp
        if pants[p] < shirts[s]:
            p += 1
        else:
            s += 1

    return best


def main():
    number_of_pants = int(input())
    pants = list(map(int, input().split()))

    number_of_shirts = int(input())
    shirts = list(map(int, input().split()))

    print(*scan(pants, number_of_pants, shirts, number_of_shirts))
```

## B

Вася очень любит везде искать своё счастливое число K. Каждый день он ходит в школу по улице, вдоль которой припарковано
N машин. Он заинтересовался вопросом, сколько существует наборов машин, стоящих подряд на местах с L до R, что сумма их
номеров равна K. Помогите Васе знать ответ на его вопрос.
Например, если число N=5, K=17, а номера машин равны 17, 7, 10, 7, 10, то существует 4 набора машин:<br>17 (L=1,R=1)
,<br>7, 10 (L=2,R=3),<br>10, 7 (L=3,R=4),<br>7, 10 (L=4,R=5)

### Формат ввода

В первой строке входных данных задаются числа N и K(1 ≤ N ≤ 100 000, 1 ≤ K ≤ 10<sup>9</sup>). Во второй строке
содержится N
чисел, задающих номера машин. Номера машин могут принимать значения от 1 до 999 включительно.

### Формат вывода

Необходимо вывести одно число — количество наборов.

<i>Example 1:</i>

| In                   | Out |
|----------------------|-----|
| 5 17<br>17 7 10 7 10 | 4   |

<i>Example 2:</i>

| In                | Out |
|-------------------|-----|
| 5 10<br>1 2 3 4 1 | 2   |

```python
n, k = list(map(int, input().split()))
cars = list(map(int, input().split()))

l = 0
r = 0
licence_plate_sum = 0
count = 0

while r < n:
    licence_plate_sum += cars[r]
    if licence_plate_sum == k:
        count += 1
        licence_plate_sum -= cars[l]
        l += 1
        r += 1
    elif licence_plate_sum < k:
        r += 1
    elif licence_plate_sum > k:
        licence_plate_sum -= cars[l]
        licence_plate_sum -= cars[r]
        l += 1
print(count)
```

## C

Александр недавно увлекся горным туризмом. Ему уже надоело покорять отдельные горные пики, и он собирается покорить
самую настоящую горную цепь!

Напомним, что Александр живет в плоском мире. Горная цепь состоит из отрезков, соединяющих точки на плоскости, каждая из
которых находится строго правее предыдущей (x-координата следующей точки больше, чем у предыдущей). Трассой на горной
цепи называется её часть между двумя фиксированными концами отрезков.

Участок, на котором при движении по трассе координата y (высота) всегда возрастает, называется подъемом, величиной
подъема называется разность высот между начальной и конечной точками участка.

Туристическая компания предлагает на выбор несколько трасс на одной горной цепи. Александр из-за финансовых трудностей
может выбрать для поездки только одну из этих трасс. Вы решили помочь ему с выбором. Александру важно для каждой трассы
определить суммарную высоту подъемов на ней. Обратите внимание, что трасса может идти как слева-направо, так и
справа-налево.

### Формат ввода

В первой строке входного файла содержится единственное число N — количество точек ломаной, задающей горную цепь (1 ≤ N ≤
30 000). Далее в N строках содержатся описания точек, каждое из которых состоит из двух целых чисел, xi и yi (1 ≤ xi, yi
≤ 30 000).

В следующей строке находится число M — количество трасс (1 ≤ M ≤ 30 000).

Далее в M строках содержатся описания трасс. Каждое описание представляет собой два целых числа, si и fi, они обозначают
номера вершин начала и конца трассы, соответственно (1 ≤ si ≤ N, 1 ≤ fi ≤ N). Начало и конец трассы могут совпадать.

Гарантируется, что во входном файле задана именно горная цепь.

### Формат вывода

Для каждой трассы выведите одно число — суммарную высоту подъемов на данной трассе.

<i>Example 1:</i>

| In                                                           | Out |
|--------------------------------------------------------------|-----|
| 7<br>2 1<br>4 5<br>7 4<br>8 2<br>9 6<br>11 3<br>15 3<br>12 6 | 4   |

<i>Example 2:</i>

| In                                                                      | Out         |
|-------------------------------------------------------------------------|-------------|
| 6<br>1 1<br>3 2<br>5 6<br>7 2<br>10 4<br>11 1<br>3<br>5 6<br>1 4<br>4 2 | 0<br>5<br>4 |

```python
def get_prefix_sum_forward(edges: list, number_of_edges: int):
    result = [0] * number_of_edges
    for i in range(1, number_of_edges):
        difference = edges[i] - edges[i - 1]
        if difference > 0:
            result[i] = result[i - 1] + difference
        else:
            result[i] = result[i - 1]
    return result


def get_prefix_sum_backward(edges: list, number_of_edges: int):
    result = [0] * number_of_edges
    for i in range(number_of_edges - 2, -1, -1):
        difference = edges[i] - edges[i + 1]
        if difference > 0:
            result[i] = result[i + 1] + difference
        else:
            result[i] = result[i + 1]
    return result


def main():
    number_of_edges = int(input())
    edges = list()

    for _ in range(number_of_edges):
        edges.append(tuple(map(int, input().split()))[1])

    number_of_routes = int(input())
    routes = list()
    for _ in range(number_of_routes):
        routes.append(tuple(map(int, input().split())))

    prefix_sum_forward = get_prefix_sum_forward(edges, number_of_edges)
    prefix_sum_backward = get_prefix_sum_backward(edges, number_of_edges)

    for start, end in routes:
        if start < end:
            result = prefix_sum_forward[end - 1] - prefix_sum_forward[start - 1]
        else:
            result = prefix_sum_backward[end - 1] - prefix_sum_backward[start - 1]
        print(result)
```

## D

В центре города Че есть пешеходная улица - одно из самых популярных мест для прогулок жителей города. По этой улице
очень приятно гулять, ведь вдоль улицы расположено n забавных памятников.

Девочке Маше из города Че нравятся два мальчика из ее школы, и она никак не может сделать выбор между ними. Чтобы
принять окончательное решение, она решила назначить обоим мальчикам свидание в одно и то же время. Маша хочет выбрать
два памятника на пешеходной улице, около которых мальчики будут ее ждать. При этом она хочет выбрать такие памятники,
чтобы мальчики не увидели друг друга. Маша знает, что из-за тумана мальчики увидят друг друга только в том случае, если
они будут на расстоянии не более r метров.

Маше заинтересовалась, а сколько способов есть выбрать два различных памятника для организации свиданий.

### Формат ввода

В первой строке входного файла находятся два целых числа n и r (2 ≤ n ≤ 300000, 1 ≤ r ≤ 10<sup>9</sup>) - количество
памятников и максимальное расстояние, на котором мальчики могут увидеть друг друга.

Во второй строке задано n положительных чисел d<sub>1</sub>, …, d<sub>n</sub>, где d<sub>i</sub> - расстояние от i-го
памятника до начала улицы. Все памятники находятся на разном расстоянии от начала улицы. Памятники приведены в порядке
возрастания расстояния от начала улицы (1 ≤ d<sub>1</sub>, d<sub>2</sub>, …, d<sub>n</sub> ≤ 10<sup>9</sup>).

### Формат вывода

Выведите одно число - число способов выбрать два памятника для организации свиданий.

<i>Example 1:</i>

| In             | Out |
|----------------|-----|
| 4 4<br>1 3 5 8 | 2   |

```python
def main():
    number_of_monuments, view_range = list(map(int, input().split()))
    distances = list(map(int, input().split()))

    count = 0
    r = 1

    for l in range(number_of_monuments):
        while r < number_of_monuments and distances[r] - distances[l] <= view_range:
            r += 1
        count += number_of_monuments - r
    print(count)
```

## E

В парке города Питсбурга есть чудесная аллея, состоящая из N посаженных в один ряд деревьев, каждое одного из K сортов. В связи с тем, что Питсбург принимает открытый чемпионат Байтландии по программированию, было решено построить огромную арену для проведения соревнований. Так, согласно этому плану вся аллея подлежала вырубке. Однако министерство деревьев и кустов воспротивилось этому решению, и потребовало оставить некоторые из деревьев в покое. Согласно новому плану строительства все деревья, которые не будут вырублены, должны образовывать один непрерывный отрезок, являющийся подотрезком исходного. Каждого из K видов деревьев требуется сохранить хотя бы по одному экземпляру. На вас возложена задача найти отрезок наименьшей длины, удовлетворяющий указанным ограничениям.

### Формат ввода

В первой строке входного файла находятся два числа N и K (1 ≤ N, K ≤ 250000). Во второй строке входного файла следуют N чисел (разделенных пробелами), i-ое число второй строки задает цвет i-ого слева дерева в аллее. Гарантируется, что присутствует хотя бы одно дерево каждого цвета

### Формат вывода

В выходной файл выведите два числа, координаты левого и правого концов отрезка минимальной длины, удовлетворяющего условию. Если оптимальных ответов несколько, выведите любой.

<i>Example 1:</i>

| In  | Out |
|-----|-----|
| 5 3<br>1 2 1 3 2 | 2 4 |

<i>Example 2:</i>

| In  | Out |
|-----|-----|
| 6 4<br>2 4 2 3 3 1 | 2 6 |

```python
def main():
    number_of_trees, number_of_species = map(int, input().split())
    trees = list(map(int, input().split()))

    # In the task output indices start from 1, thus 1 and len(trees)
    best = [1, number_of_trees]

    l = r = 0
    unique_trees = dict()
    
    while r < number_of_trees:
        cur_tree = trees[r]

        if cur_tree not in unique_trees:
            unique_trees[cur_tree] = 0
        unique_trees[cur_tree] += 1

        # When we have completed tree array
        if len(unique_trees) == number_of_species:
            cur_tree = trees[l]
            # Find the single tree of any species
            while unique_trees[cur_tree] > 1:
                unique_trees[cur_tree] -= 1
                l += 1
                cur_tree = trees[l]
            # After we found the only one tree of some species, compare current tree array with the best one
            if r - l < best[1] - best[0]:
                best = (l + 1, r + 1)
        r += 1
    print(*best)
```

## F

При реализации проекта «Умная школа» было решено в каждый учебный класс выбранной для этого школы установить по кондиционеру нового поколения для автоматического охлаждения и вентиляции воздуха. По проекту в каждом классе должен быть установлен только один кондиционер и мощность кондиционера должна быть достаточной для размеров класса. Чем больше класс, тем мощнее должен быть кондиционер.

Все классы школы пронумерованы последовательно от 1 до n. Известно, что для каждого класса с номером i, требуется ровно один кондиционер, мощность которого больше или равна ai ватт.

Администрации школы предоставили список из m различных моделей кондиционеров, которые можно закупить. Для каждой модели кондиционера известна его мощность и стоимость. Требуется написать программу, которая определит, за какую минимальную суммарную стоимость кондиционеров можно оснастить все классы школы.

### Формат ввода

Первая строка входного файла содержит одно целое число n (1 ≤ n ≤ 50 000) количество классов в школе.

Вторая строка содержит n целых чисел ai (1 ≤ ai ≤ 1000) — минимальная мощность кондиционера в ваттах, который можно установить в классе с номером i.

Третья строка содержит одно целое число m (1 ≤ m ≤ 50 000) — количество предложенных моделей кондиционеров.

Далее, в каждой из m строк содержится пара целых чисел bj и cj (1 ≤ bj ≤ 1000, 1 ≤ cj ≤ 1000) мощность в ваттах j-й модели кондиционера и его цена в рублях соответственно.

### Формат вывода

Выходной файл должен содержать одно число минимальную суммарную стоимость кондиционеров в рублях. Гарантируется, что хотя бы один корректный выбор кондиционеров существует, и во всех классах можно установить подходящий кондиционер.

<i>Example 1:</i>

| In  | Out |
|---------------------------|------|
| 1<br>800<br>1<br>800 1000 | 1000 |

<i>Example 2:</i>

| In  | Out |
|-----------------------------------------------|-----|
| 3<br>1 2 3<br>4<br>1 10<br>1 5<br>10 7<br>2 3 | 13  |

```python
def countPriceN(numberOfRooms: int, rooms: list, conditionerModels: int, conditioners: list):
    conditioners = sorted(conditioners, key=lambda conditioner: conditioner[0])
    rooms = sorted(rooms, reverse=True)
    result = 0
    minPrice = 1001
    r = len(conditioners) - 1
    for room in rooms:
        while r >= 0 and room <= conditioners[r][0]:
            if conditioners[r][1] < minPrice:
                minPrice = conditioners[r][1]
            r -= 1
        result += minPrice

    print(result)


def main():
    numberOfRooms = int(input())
    rooms = list(map(int, input().split()))

    conditionerModels = int(input())
    conditioners = list()
    for _ in range(conditionerModels):
        conditioners.append(tuple(map(int, input().split())))

    countPriceN(numberOfRooms, rooms, conditionerModels, conditioners)
```

## G

Андрей работает судьей на чемпионате по гипершашкам. В каждой игре в гипершашки участвует три игрока. По ходу игры каждый из игроков набирает некоторое положительное целое число баллов. Если после окончания игры первый игрок набрал a баллов, второй — b, а третий c, то говорят, что игра закончилась со счетом a:b:c.

Андрей знает, что правила игры гипершашек устроены таким образом, что в результате игры баллы любых двух игроков различаются не более чем в k раз.

После матча Андрей показывает его результат, размещая три карточки с очками игроков на специальном табло. Для этого у него есть набор из n карточек, на которых написаны числа x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub>. Чтобы выяснить, насколько он готов к чемпионату, Андрей хочет понять, сколько различных вариантов счета он сможет показать на табло, используя имеющиеся карточки.

Требуется написать программу, которая по числу k и значениям чисел на карточках, которые имеются у Андрея, определяет количество различных вариантов счета, которые Андрей может показать на табло.

### Формат ввода

Первая строка входного файла содержит два целых числа: n и k (3 ≤ n ≤ 100000, 1 ≤ k ≤ 10<sup>9</sup>).

Вторая строка входного файла содержит n целых чисел x<sub>1</sub>, x<sub>2</sub>, …, x<sub>n</sub> (1 ≤ x<sub>i</sub> ≤ 10<sup>9</sup>).

### Формат вывода

Выходной файл должен содержать одно целое число — искомое количество различных вариантов счета.

<i>Example 1:</i>

| In  | Out |
|------------------|-----|
| 5 2<br>1 1 2 2 3 | 9   |

```python
def main():
    number_of_cards, max_difference = list(map(int, input().split()))
    card_list = list(map(int, input().split()))
    cards = dict()
    for card in card_list:
        if card not in cards:
            cards[card] = 0
        cards[card] += 1

    unique_cards = sorted(cards.keys())

    r = 0
    duplicates = 0
    result = 0

    for l in range(len(unique_cards)):
        while r < len(unique_cards) and unique_cards[l] * max_difference >= unique_cards[r]:
            if cards[unique_cards[r]] >= 2:
                duplicates += 1
            r += 1
        current_range = r - l
        if cards[unique_cards[l]] >= 2:
            duplicates -= 1
            result += (current_range - 1) * 3
        result += duplicates * 3
        if cards[unique_cards[l]] >= 3:
            result += 1
        # arithmetic progression sum
        result += (current_range - 1) * (current_range - 2) * 3

    print(result)
```

## H

В этой задаче Вам требуется найти максимальную по длине подстроку данной строки, такую что каждый символ встречается в ней не более k раз.

### Формат ввода

В первой строке даны два целых числа n и k (1 ≤ n ≤ 100000, 1 ≤ k ≤ n ) , где n – количество символов в строке. Во второй строке n символов – данная строка, состоящая только из строчных латинских букв.

### Формат вывода

В выходной файл выведите два числа – длину искомой подстроки и номер её первого символа. Если решений несколько, выведите любое.

<i>Example 1:</i>

| In  | Out |
|-----|-----|
| 3 1<br>abb | 2 1 |

<i>Example 2:</i>

| In  | Out |
|-----|-----|
| 5 2<br>ababa | 4 1 |

```python
def main():
    length, max_instances = map(int, input().split())
    string = list(input())

    l = 0
    r = 0
    # In the task output index starts from 1, thus 0 and 1
    best = (0, 1)

    alphabet = dict()

    while r < length:
        cur_letter = string[r]

        # If we haven't met this letter OR we "deleted" it previously
        if cur_letter not in alphabet or alphabet[cur_letter]['counter'] == 0:
            alphabet[cur_letter] = {'counter': 0, 'first': r}
        alphabet[cur_letter]['counter'] += 1

        if alphabet[cur_letter]['counter'] > max_instances:
            # We need to compare previous best result with the current one, but not include current r'th symbol, thus only r - l
            if best[0] < (r - l):
                best = (r - l, l + 1)

            # Discard all letters met before and first occurence of current letter
            while l <= alphabet[cur_letter]['first']:
                alphabet[string[l]]['counter'] -= 1
                l += 1

            # Then find the next occurence of the current letter to change the "first" param
            k = l
            while string[k] != cur_letter:
                k += 1
            alphabet[cur_letter]['first'] = k
        # If we haven't exceded the limit compare previous best with the current one including current letter, thus r - l + 1
        elif best[0] <= (r - l + 1):
            best = (r - l + 1, l + 1)
        r += 1

    print(*best)
```

## I

Студенты одного из вузов спроектировали робота для частичной автоматизации процесса сборки авиационного двигателя.

В процессе сборки двигателя могут встречаться операции 26 типов, которые обозначаются строчными буквами латинского алфавита. Процесс сборки состоит из N операций.

Предполагается использовать робота один раз для выполнения части подряд идущих операций из процесса сборки.

Память робота состоит из K ячеек, каждая из которых содержит одну операцию. Операции выполняются последовательно, начиная с первой, в том порядке, в котором они расположены в памяти. Выполнив последнюю из них, робот продолжает работу с первой. Робота можно остановить после любой операции. Использование робота экономически целесообразно, если он выполнит хотя бы K + 1 операцию.

Требуется написать программу, которая по заданному процессу сборки определит количество экономически целесообразных способов использования робота.

### Формат ввода

В первой строке входного файла записано число K > 0 — количество операций, которые можно записать в память робота.

Вторая строка состоит из N > K строчных латинских букв, обозначающих операции — процесс сборки двигателя. Операции одного и того же типа обозначаются одной и той же буквой. N ≤ 200000

### Формат вывода

Выходной файл должен содержать единственное целое число — количество экономически целесообразных способов использования робота.

<i>Example 1:</i>

| In  | Out |
|-----|-----|
| 2<br>zabacabab | 5   |

<i>Example 2:</i>

| In  | Out |
|-----|-----|
| 2<br>abc | 0  |

```python
def main():
    k = int(input())
    operations = input()
    result = 0
    previous_count_length = 0
    for i in range(k, len(operations)):
        if operations[i] == operations[i-k]:
            previous_count_length += 1
        else:
            previous_count_length = 0
        result += previous_count_length
    print(result)
```

## J

Петя достаточно давно занимается в математическом кружке, поэтому он уже успел не только правила выполнения простейших операций, но и такое достаточно сложное понятие как симметрия. Для того, чтобы получше изучить симметрию Петя решил начать с наиболее простых геометрических фигур – треугольников. Он скоро понял, что осевой симметрией обладают так называемые равнобедренные треугольники. Поэтому теперь Петя ищет везде такие треугольники.

Напомним, что треугольник называется равнобедренным, если его площадь положительна, и у него есть хотя бы две равные стороны.

Недавно Петя, зайдя в класс, увидел, что на доске нарисовано n точек. Разумеется, он сразу задумался, сколько существует троек из этих точек, которые являются вершинами равнобедренных треугольников.

Требуется написать программу, решающую указанную задачу.

### Формат ввода

Входной файл содержит целое число n (3 ≤ n ≤ 1500). Каждая из последующих строк содержит по два целых числа – xi и yi – координаты i-ой точки. Координаты точек не превосходят 109 по абсолютной величине. Среди заданных точек нет совпадающих.

<i>Example 1:</i>

| In                      | Out |
|-------------------------|-----|
| 3<br>0 0<br>2 2<br>-2 2 | 1   |

<i>Example 2:</i>

| In                            | Out |
|-------------------------------|-----|
| 4<br>0 0<br>1 1<br>1 0<br>0 1 | 4   |

```python
number_of_points = int(input())

points = list()

for _ in range(number_of_points):
    points.append(list(map(int, input().split())))

result = 0

for i in range(number_of_points):
    processed_vectors = set()
    neighbours = list()
    for j in range(number_of_points):
        x_cord = points[j][0] - points[i][0]
        y_cord = points[j][1] - points[i][1]
        neighbours.append(x_cord ** 2 + y_cord ** 2)

        if (x_cord, y_cord) in processed_vectors:
            result -= 1
        processed_vectors.add((-x_cord, -y_cord))

    neighbours.sort()
    neighbours_length = len(neighbours)
    r = 0
    for l in range(neighbours_length):
        while r < neighbours_length and neighbours[l] == neighbours[r]:
            r += 1
        result += r - l - 1
print(result)
```

