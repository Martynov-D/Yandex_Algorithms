Link: <https://contest.yandex.ru/contest/27663/enter/>

## A

Дан список чисел, который может содержать до 100000 чисел. Определите, сколько в нем встречается различных чисел.

### Формат ввода

Вводится список целых чисел. Все числа списка находятся на одной строке.

### Формат вывода

Выведите ответ на задачу

<i>Example 1:</i>

| In         | Out |
|------------|-----|
| 1 2 3 2  3 | 3   |

<i>Example 2:</i>

| In                   | Out |
|----------------------|-----|
| 1 2 3 4 5 6 7 8 9 10 | 10  |

<i>Example 3:</i>

| In                    | Out |
|-----------------------|-----|
| 1 2 3 4 5 1 2 1 2 7 3 | 6   |

```python
# numbers = set(map(int, input().split()))
# unique_numbers = set()
# for number in numbers:
#	if number not in unique_numbers:
#		unique_numbers.add(number)
print(len(set(map(int, input().split()))))
```

## B

Даны два списка чисел, которые могут содержать до 10000 чисел каждый. Выведите все числа, которые входят как в первый,
так и во второй список в порядке возрастания. Примечание. И даже эту задачу на Питоне можно решить в одну строчку.

### Формат ввода

Вводятся два списка целых чисел. Все числа каждого списка находятся на отдельной строке.

<i>Example 1:</i>

| In             | Out |
|----------------|-----|
| 1 3 2<br>4 3 2 | 2 3 |

<i>Example 2:</i>

| In                        | Out |
|---------------------------|-----|
| 1 2 6 4 5 7<br>10 2 3 4 8 | 2 4 |

```python
def main():
    first = list(map(int, input().split()))
    second = set(map(int, input().split()))

    i = 0
    while i != len(first):
        if first[i] not in second:
            first[i] = first[len(first) - 1]
            first.pop()
        else:
            i += 1

    print(*sorted(first))


# 1 line solution
print(*sorted(set(map(int, input().split())).intersection(set(map(int, input().split())))))
```

## C

Аня и Боря любят играть в разноцветные кубики, причем у каждого из них свой набор и в каждом наборе все кубики различны
по цвету. Однажды дети заинтересовались, сколько существуют цветов таких, что кубики каждого цвета присутствуют в обоих
наборах. Для этого они занумеровали все цвета случайными числами. На этом их энтузиазм иссяк, поэтому вам предлагается
помочь им в оставшейся части. Номер любого цвета — это целое число в пределах от 0 до 10<sup>9</sup>.

### Формат ввода

В первой строке входного файла записаны числа N и M — количество кубиков у Ани и Бори соответственно. В следующих N
строках заданы номера цветов кубиков Ани. В последних M строках номера цветов кубиков Бори.

### Формат вывода

Выведите сначала количество, а затем отсортированные по возрастанию номера цветов таких, что кубики каждого цвета есть в
обоих наборах, затем количество и отсортированные по возрастанию номера остальных цветов у Ани, потом количество и
отсортированные по возрастанию номера остальных цветов у Бори.

<i>Example 1:</i>

| In                                      | Out                             |
|-----------------------------------------|---------------------------------|
| 4 3<br>0<br>1<br>10<br>9<br>1<br>3<br>0 | 2<br>0 1<br>2<br>9 10<br>1<br>3 |

<i>Example 2:</i>

| In                       | Out                        |
|--------------------------|----------------------------|
| 2 2<br>1<br>2<br>2<br>3  | 1<br>2<br>1<br>1<br>1<br>3 |

<i>Example 3:</i>

| In  | Out         |
|-----|-------------|
| 0 0 | 0<br>0<br>0 |

```python
def main():
    n, m = list(map(int, input().split()))

    ann = set()
    borya = set()
    intersection = set()

    for _ in range(n):
        ann.add(int(input()))
    for _ in range(m):
        element = int(input())
        if element in ann:
            intersection.add(element)
            ann.remove(element)
        else:
            borya.add(element)

    print(len(intersection))
    print(*sorted(intersection))
    print(len(ann))
    print(*sorted(ann))
    print(len(borya))
    print(*sorted(borya))
```

## D

Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку sys) записан текст. Словом считается
последовательность символов, не пробелов, идущих подряд. Слова разделены одним или большим числом пробелов или символами
конца строки. Определите, сколько различных слов содержится в этом тексте.

<i>Example 1:</i>

| In                                                                                                                                                                                             | Out |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----|
| She sells sea shells on the sea shore;<br>The shells that she sells are sea shells I'm sure.<br>So if she sells sea shells on the sea shore,<br>I'm sure that the shells are sea shore shells. | 19  |

```python
def main():
    text = set()
    with open('input.txt', 'r') as f:
        for line in f:
            for word in line.split():
                text.add(word)
    print(len(text))
```

## E

В новой программе OpenCalculator появилась новая возможность – можно настроить, какие кнопки отображаются, а какие –
нет. Если кнопка не отображается на экране, то ввести соответствующую цифру с клавиатуры или копированием из другой
программы нельзя. Петя настроил калькулятор так, что он отображает только кнопки с цифрами x, y, z. Напишите программу,
определяющую, сможет ли Петя ввести число N, а если нет, то какое минимальное количество кнопок надо дополнительно
отобразить на экране для его ввода.

### Формат ввода

Сначала вводятся три различных числа из диапазона от 0 до 9: x, y и z (числа разделяются пробелами). Далее вводится
целое неотрицательное число N, которое Петя хочет ввести в калькулятор. Число N не превышает 10000.

### Формат вывода

Выведите, какое минимальное количество кнопок должно быть добавлено для того, чтобы можно было ввести число N (если
число может быть введено с помощью уже имеющихся кнопок, выведите 0)

<i>Example 1:</i>

| In            | Out |
|---------------|-----|
| 1 2 3<br>1123 | 0   |

<i>Example 2:</i>

| In            | Out |
|---------------|-----|
| 1 2 3<br>1001 | 1   |

<i>Example 3:</i>

| In           | Out |
|--------------|-----|
| 5 7 3<br>123 | 2   |

```python
def main():
    buttons = set(map(int, input().split()))
    number = set(map(int, list(input())))

    count = 0
    for digit in number:
        if digit not in buttons:
            count += 1
    print(count)
```

## F

Геном жителей системы Тау Кита содержит 26 видов оснований, для обозначения которых будем использовать буквы латинского
алфавита от A до Z, а сам геном записывается строкой из латинских букв. Важную роль в геноме играют пары соседних
оснований, например, в геноме «ABBACAB» можно выделить следующие пары оснований: AB, BB, BA, AC, CA, AB.

Степенью близости одного генома к другому геному называется количество пар соседних оснований первого генома, которые
встречаются во втором геноме.

Вам даны два генома, определите степень близости первого генома второму геному. Программа получает на вход две строки,
состоящие из заглавных латинских букв. Каждая строка непустая, и её длина не превосходит 10<sup>5</sup>.

Программа должна вывести одно целое число – степень близости генома, записанного в первой строке, геному, записанному во
второй строке.

<i>Example 1:</i>

| In                 | Out |
|--------------------|-----|
| ABBACAB<br>BCABB 4 | 4   |

```python
def main():
    gen1 = input()
    gen2 = input()

    gen2_s = set()
    for i in range(1, len(gen2)):
        gen2_s.add(gen2[i - 1:i + 1])

    count = 0
    for i in range(1, len(gen1)):
        temp = gen1[i - 1:i + 1]
        if temp in gen2_s:
            count += 1
    print(count)
```

## G

Широко известна следующая задача для младших школьников. Три черепахи ползут по дороге. Одна черепаха говорит: “Впереди
меня две черепахи”. Другая черепаха говорит: “Позади меня две черепахи”. Третья черепаха говорит: “Впереди меня две
черепахи и позади меня две черепахи”. Как такое может быть? Ответ: третья черепаха врет! По дороге одна за другой
движутся N черепах. Каждая черепаха говорит фразу вида: “Впереди меня ai черепах, а позади меня bi черепах”. Ваша задача
определить наибольшее количество черепах, которые могут говорить правду.

### Формат ввода

В первой строке вводится целое число N (1 ≤ N ≤ 10000) строк, содержащих целые числа ai и bi, по модулю не превосходящие
10<sup>4</sup>, описывающие высказывание i-ой черепахи.

### Формат вывода

Выведите целое число M – максимальное количество черепах, которые могут говорить правду.

<i>Example 1:</i>

| In                       | Out |
|--------------------------|-----|
| 3<br>2 0<br>0 2<br>2 2 2 | 2   |

<i>Example 2:</i>

| In                                   | Out |
|--------------------------------------|-----|
| 5<br>0 4<br>1 3<br>2 2<br>3 1<br>4 0 | 5   |

<i>Example 3:</i>

| In                                                                       | Out |
|--------------------------------------------------------------------------|-----|
| 10<br>9 1<br>8 1<br>7 2<br>6 2<br>5 3<br>4 4<br>3 6<br>2 7<br>1 9<br>0 8 | 4   |

```python
def main():
    number_of_turtles = int(input())
    turtles = set()
    for _ in range(number_of_turtles):
        turtle = tuple(map(int, input().split()))
        if turtle[0] < 0 or turtle[1] < 0:
            pass
        elif turtle[0] + turtle[1] == number_of_turtles - 1:
            turtles.add(turtle)
    print(len(turtles))
```

## H

Вы никогда не задумывались, почему в Angry Birds у птиц нет крыльев? Тем же вопросом задались разработчики новой игры. В
их версии смысл игры прямо противоположен Angry Birds: зеленая свинка стреляет по злым птицам из лазерного ружья (
завязка явно не хуже исходной игры).

Птицы в игре представляются точками на плоскости. Выстрел сбивает только ближайшую птицу находящуюся на линии огня. При
этом сбитая птица падая сбивает всех птиц, находящихся ровно под ней. Две птицы не могут находиться в одной точке. По
заданному расположению птиц необходимо определить, какое минимальное количество выстрелов необходимо, чтобы все птицы
были сбиты.

### Формат ввода

Первая строка входного файла содержит единственное целое число N (1 ≤ N ≤ 10<sup>3</sup>) — количество птиц.

Следующие N строк содержат по два натуральных числа каждая xi, yi — координаты i-ой птицы (0 < x, y ≤ 10<sup>9</sup>).
Свинка находится в точке с координатами (0, 0).

### Формат вывода

Единственная строка выходного файла должна содержать одно целое число — минимальное количество выстрелов, необходимое
для того, чтобы сбить всех птиц.

<i>Example 1:</i>

| In                                              | Out |
|-------------------------------------------------|-----|
| 6<br>1 1<br>2 2<br>3 3<br>2 1<br>3 2<br>3 1<br> | 3   |

<i>Example 2:</i>

| In                                               | Out |
|--------------------------------------------------|-----|
| 6<br>1 1<br>2 2<br>3 3<br>2 1<br>3 2<br>3 4<br>  | 3   |

```python
def main():
    number_of_birds = int(input())
    birds = set()
    for _ in range(number_of_birds):
        # Птицы делятся по первой координате на столбцы.
        # Один выстрел = один столбец. Поэтому сделаем множество из х координат.
        # Таким образом размер множества станет минимальным количеством выстрелов.
        x, y = map(int, input().split())
        if x not in birds:
            birds.add(x)

    print(len(birds))
```

Решение со словарем работает быстрее в тестирующей системе.

| Решение   | Время | Память |
|-----------|-------|--------|
| Множество | 70ms  | 3.92Mb |
| Словарь   | 44ms  | 3.95Mb |

## I

Каждый из N школьников некоторой школы знает M<sub>i</sub> языков. Определите, какие языки знают все школьники и языки,
которые знает хотя бы один из школьников.

### Формат ввода

Первая строка входных данных содержит количество школьников N. Далее идет N чисел Mi, после каждого из чисел идет Mi
строк, содержащих названия языков, которые знает i-й школьник. Длина названий языков не превышает 1000 символов,
количество различных языков не более 1000. 1 ≤ N ≤ 1000, 1 ≤ Mi ≤ 500.

### Формат вывода

В первой строке выведите количество языков, которые знают все школьники. Начиная со второй строки - список таких языков.
Затем - количество языков, которые знает хотя бы один школьник, на следующих строках - список таких языков.

<i>Example 1:</i>

| In                                                                                  | Out                                                 |
|-------------------------------------------------------------------------------------|-----------------------------------------------------|
| 3<br>3<br>Russian<br>English<br>Japanese<br>2<br>Russian<br>English<br>1<br>English | 1<br>English<br>3<br>Russian<br>Japanese<br>English |

```python
def main():
    number_of_students = int(input())
    languages = set()
    students = list()
    for _ in range(number_of_students):
        number_of_languages = int(input())
        current_student_languages = set()
        for _ in range(number_of_languages):
            language = input()
            languages.add(language)
            current_student_languages.add(language)
        students.append(current_student_languages)

    inter = students[0]
    for student in students[1:]:
        inter = inter.intersection(student)

    print(len(inter))
    for i in inter:
        print(i)
    print(len(languages))
    for i in languages:
        print(i)
```

## J

Дороги Нью-Манхэттена устроены следующим образом. С юга на север через каждые сто метров проходит авеню, с запада на
восток через каждые сто метров проходит улица. Авеню и улицы нумеруются целыми числами. Меньшие номера соответствуют
западным авеню и южным улицам. Таким образом, можно построить прямоугольную систему координат так, чтобы точка (x, y)
лежала на пересечении x-ой авеню и y-ой улицы. Легко заметить, что для того, чтобы в Нью-Манхэттене дойти от точки (x1,
y1) до точки (x2, y2) нужно пройти |x2 − x1| + |y2 − y1| кварталов. Эта величина называется манхэттенским расстоянием
между точками (x1, y1) и (x2, y2).

Миша живет в Нью-Манхэттене и каждое утро делает пробежку по городу. Он выбегает из своего дома, который находится в
точке (0, 0) и бежит по случайному маршруту. Каждую минуту Миша либо остается на том же перекрестке, что и минуту назад,
или перемещается на один квартал в любом направлении. Чтобы не заблудиться Миша берет с собой навигатор, который каждые
t минут говорит Мише, в какой точке он находится. К сожалению, навигатор показывает не точное положение Миши, он может
показать любую из точек, манхэттенское расстояние от которых до Миши не превышает d.

Через t × n минут от начала пробежки, получив n-е сообщение от навигатора, Миша решил, что пора бежать домой. Для этого
он хочет понять, в каких точках он может находиться. Помогите Мише сделать это.

### Формат ввода

Первая строка входного файла содержит числа t, d и n (1 ≤ t ≤ 100, 1 ≤ d ≤ 100, 1 ≤ n ≤ 100).

Далее n строк описывают данные, полученные от навигатора. Строка номер i содержит числа xi и yi — данные, полученные от
навигатора через ti минут от начала пробежки.

### Формат вывода

В первой строке выходного файла выведите число m — число точек, в которых может находиться Миша. Далее выведите m пар
чисел — координаты точек. Точки можно вывести в произвольном порядке.

Гарантируется, что навигатор исправен и что существует по крайней мере одна точка, в которой может находиться Миша.

<i>Example :</i>

| In                                         | Out             |
|--------------------------------------------|-----------------|
| 2 1 5<br>0 1<br>-2 1<br>-2 3<br>0 3<br>2 5 | 2<br>1 5<br>2 4 |

<i>Example :</i>

| In           | Out                                    |
|--------------|----------------------------------------|
| 1 1 1<br>0 0 | 5<br>-1 0<br>0 -1<br>0 0<br>0 1<br>1 0 |

<i>Example :</i>

| In            | Out                                    |
|---------------|----------------------------------------|
| 1 10 1<br>0 0 | 5<br>-1 0<br>0 -1<br>0 0<br>0 1<br>1 0 |

```python
def resize(rect, interval):
    minP, maxP, minM, maxM = rect
    return [minP - interval, maxP + interval, minM - interval, maxM + interval]


def intersect(rect1, rect2):
    return [max(rect1[0], rect2[0]), min(rect1[1], rect2[1]), max(rect1[2], rect2[2]), min(rect1[3], rect2[3])]


def with_functions():
    interval, error, number_of_messages = map(int, input().split())
    rect = [0, 0, 0, 0]

    for i in range(number_of_messages):
        rect = resize(rect, interval)
        x_nav, y_nav = map(int, input().split())
        nav_rect = resize([y_nav + x_nav, y_nav + x_nav, x_nav - y_nav, x_nav - y_nav], error)
        rect = intersect(rect, nav_rect)

    points = list()
    for yx in range(rect[0], rect[1] + 1):
        for y_x in range(rect[2], rect[3] + 1):
            if (yx + y_x) % 2 == 0:
                x = (yx + y_x) // 2
                y = yx - x
                points.append((x, y))

    print(len(points))
    for point in points:
        print(*point)


def without_functions():
    interval, error, number_of_messages = map(int, input().split())

    # y = x
    min_y_x = 0
    max_y_x = 0
    # y = -x
    min_yx = 0
    max_yx = 0

    for i in range(number_of_messages):
        # resize
        # y = x
        min_y_x -= interval
        max_y_x += interval
        # y = -x
        min_yx -= interval
        max_yx += interval

        x_nav, y_nav = map(int, input().split())
        # (y - nav_y) = (x - nav_x) +- error
        nav_min_y_x = -error + x_nav - y_nav
        nav_max_y_x = error + x_nav - y_nav
        # (y - nav_y) = -(x - nav_x) +- error
        nav_min_yx = -error + y_nav + x_nav
        nav_max_yx = error + y_nav + x_nav

        # intersect
        min_y_x = max(min_y_x, nav_min_y_x)
        max_y_x = min(max_y_x, nav_max_y_x)
        min_yx = max(min_yx, nav_min_yx)
        max_yx = min(max_yx, nav_max_yx)

    points = list()
    for yx in range(min_yx, max_yx + 1):
        for y_x in range(min_y_x, max_y_x + 1):
            if (yx + y_x) % 2 == 0:
                x = (yx + y_x) // 2
                y = yx - x
                points.append((x, y))

    print(len(points))
    for point in points:
        print(*point)
```