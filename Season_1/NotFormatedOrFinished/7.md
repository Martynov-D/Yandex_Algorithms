Link: <https://contest.yandex.ru/contest/27883>

## A

На первом курсе одной Школы, учится 1 ≤ N ≤ 10<sup>9</sup> студентов. При проведении экзаменов студентов рассаживают в ряд, каждого за своей партой. Парты пронумерованы числами от 0 до N - 1.
Известно, что студент, оставшись без наблюдения, открывает телефон и начинает искать ответы на экзамен в поисковике Яндекса.
Поэтому было решено позвать M преподавателей наблюдать за студентами. Когда за студентом наблюдает хотя бы один преподаватель, он стесняется и не идет искать ответы к экзамену. Преподаватель с номером i видит студентов сидящих за партами от b<sub>i</sub> до e<sub>i</sub> включительно.
Необходимо посчитать количество студентов, которые все таки будут искать ответы к экзамену в Яндексе

### Формат ввода

В первой строке находятся два целых числа 1 ≤ N ≤ 10<sup>9</sup>, 1 ≤ M ≤ 10<sup>4</sup> — число студентов и число преподавателей соответственно. В следующих M строках содержится по два целых числа 0 ≤ b<sub>i</sub> ≤ e<sub>i</sub> ≤ N - 1 — парты, за которыми наблюдает i-й преподаватель.

### Формат вывода

Выведите одно число — количество студентов оставшихся без наблюдения.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 10 3<br>1 3<br>2 4<br>9 9 | 5 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 10 2<br>1 1<br>1 2 | 8 |

```python
def main():
    N, M = map(int, input().split())

    teachers = [[0, 0] for _ in range(M)]
    for i in range(M):
        teachers[i][0], teachers[i][1] = map(int, input().split())
    teachers.sort()

    watched_tables = teachers[0][1] - teachers[0][0] + 1
    last = teachers[0][1]

    for teacher in teachers[1:]:
        # Правая - левая + 1 == количество просматриваемых парт, включая границы
        # для левой границы используется максимум из левой и предыдущей + 1, чтобы правильно обработать случай,
        # когда интервалы пересекаются, и пограничный элемент включается дважды.
        watched_tables += max(teacher[1], last) - max(teacher[0], last + 1) + 1
        last = max(last, teacher[1])

    print(N - watched_tables)
```

## B

Дано n отрезков на числовой прямой и m точек на этой же прямой. Для каждой из данных точек определите, скольким отрезкам они принадлежат. Точка x считается принадлежащей отрезку с концами a и b, если выполняется двойное неравенство min(a, b) ≤ x ≤ max(a, b).

### Формат ввода

Первая строка содержит два целых числа n (1 ≤ n ≤ 10<sup>5</sup>) – число отрезков и m (1 ≤ m ≤ 10<sup>5</sup>) – число точек. В следующих n строках по два целых числи a<sub>i</sub> и b<sub>i</sub> – координаты концов соответствующего отрезка. В последней строке m целых чисел – координаты точек. Все числа по модулю не превосходят 10<sup>9</sup>

### Формат вывода

В выходной файл выведите m чисел – для каждой точки количество отрезков, в которых она содержится.

<i>Example :</i>

| In                     | Out |
|------------------------|-----|
| 3 2<br>0 5<br>-3 2<br>7 10<br>1 6 | 2 0 |

```python
def main():
    events = list()
    n = None
    m = None

    with open('input.txt', 'r') as f:
        n, m = map(int, f.readline().split())
        for _ in range(n):
            start, end = map(int, f.readline().split())
            start, end = min(start, end), max(start, end)
            events.append([start, -1])
            events.append([end, 1])

        i = 0
        for point in map(int, f.readline().split()):
            events.append([point, 0, i])
            i += 1

    events.sort()

    start_points = 0
    points = [0] * m

    for event in events:
        match event[1]:
            case -1:
                start_points += 1
            case 1:
                start_points -= 1
            case 0:
                points[event[2]] = start_points

    print(' '.join(points))
```

## C TODO

Экзамен по берляндскому языку проходит в узкой и длинной аудитории. На экзамен пришло N студентов. Все они посажены в ряд. Таким образом, позиция каждого человека задается координатой на оси Ox (эта ось ведет вдоль длинной аудитории). Два человека могут разговаривать, если расстояние между ними меньше или равно D. Какое наименьшее количество типов билетов должен подготовить преподаватель, чтобы никакие два студента с одинаковыми билетами не могли разговаривать? Выведите способ раздачи преподавателем билетов.

### Формат ввода

В первой строке входного файла содержится два целых числа N, D (1 ≤ N ≤ 10 000; 0 ≤ D ≤ 10<sup>6</sup>). Вторая строка содержит последовательность различных целых чисел X<sub>1</sub>, X<sub>2</sub>, ..., X<sub>N</sub>, где X<sub>i</sub> (0 ≤ X<sub>i</sub> ≤ 10<sup>6</sup>) обозначает координату вдоль оси Ox i-го студента

### Формат вывода

В первую строчку выходного файла выведите количество вариантов, а во вторую, разделяя пробелами, номера вариантов студентов в том порядке, в каком они перечислены во входном файле.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 4 1<br>11 1 12 2 | 2<br>1 1 2 2 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 4 0<br>11 1 12 2 | 1<br>1 1 1 1 |

```python
# TODO

def main():
    number_of_students, distance = map(int, input().split())

    students = [0] * number_of_students
    events = [0] * (number_of_students * 2) 
    for i, student in enumerate(map(int, input().split())):
        events[i * 2] = (int(student), -1)
        events[i * 2 + 1] = (int(student) + distance, 1)
    events.sort()
    print(events)

    # Нашли количество вариантов
    variant = 0
    n_variants = -1
    for event in events:
        match event[1]:
            case -1:
                variant += 1
                n_variants = max(n_variants, variant)
            case 1:
                variant -= 1
                
    # надо раздать варианты
    print(n_variants)
    print(*students)
```

## D

Фирма NNN решила транслировать свой рекламный ролик в супермаркете XXX. Однако денег, запланированных на рекламную кампанию, хватило лишь на две трансляции ролика в течение одного рабочего дня.
Фирма NNN собрала информацию о времени прихода и времени ухода каждого покупателя в некоторый день. Менеджер по рекламе предположил, что и на следующий день покупатели будут приходить и уходить ровно в те же моменты времени.
Помогите ему определить моменты времени, когда нужно включить трансляцию рекламных роликов, чтобы как можно большее количество покупателей прослушало ролик целиком от начала до конца хотя бы один раз. Ролик длится ровно 5 единиц времен. Трансляции роликов не должны пересекаться, то есть начало второй трансляции должно быть хотя бы на 5 единиц времени позже, чем начало первой.
Если трансляция ролика включается, например, в момент времени 10, то покупатели, пришедшие в супермаркет в момент времени 10 (или раньше) и уходящие из супермаркета в момент 15 (или позднее) успеют его прослушать целиком, а, например, покупатель, пришедший в момент времени 11, равно как и покупатель, уходящий в момент 14 - не успеют. Если покупатель успевает услышать только конец первой трансляции ролика (не сначала) и начало второй трансляции (не до конца), то считается, что он не услышал объявления. Если покупатель успевает услышать обе трансляции ролика, то при подсчете числа людей, прослушавших ролик, он все равно учитывается всего один раз (фирме важно именно количество различных людей, услышавших ролик).

### Формат ввода

В первой строке входного файла вводится число N - количество покупателей (1 ≤ N ≤ 2000). В следующих N строках записано по паре натуральных чисел - время прихода и время ухода каждого из них. Все значения времени - натуральные числа, не превышающие 10<sup>9</sup>. Время ухода человека из супермаркета всегда строго больше времени его прихода в супермаркет.

### Формат вывода

Выведите через пробел три числа: количество покупателей, которые прослушают ролик целиком от начала до конца хотя бы один раз, и моменты времени, когда должна начинаться трансляция ролика. Моменты времени должны быть выведены в возрастающем порядке и должны быть натуральными числами, не превышающими 2*10<sup>9</sup>. Если вариантов ответа несколько, выведите любой из них.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 4<br>1 11<br>1 3<br>6 15<br>1 6 | 3 1 6 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 1<br>1 10 | 1 3 25 |

<i>Example 3:</i>

| In                     | Out |
|------------------------|-----|
| 3<br>1 10<br>11 20<br>21 30<br>1 6 | 2 1 22 |

```python
def main():
    entered = -1
    left = 1
    with open('input.txt', 'r') as f:
        number_of_customers = int(f.readline())
        events = list()
        for i in range(number_of_customers):
            start, end = list(map(int, f.readline().split()))
            # Забираем покупателя, если он был в магазине достаточное время для показа рекламы.
            if end - start >= 5:
                events.append((start, entered, i))
                # Добавляем событие ухода покупателя на 5 минут раньше,
                # чтобы не учитывать его в подсчетах и не получить неверный результат.
                events.append((end - 5, left, i))
    events.sort()
    
    # Если покупателей совсем нет, то показываем в любое время с интервалом.
    if len(events) == 0:
        return (0, 10, 20,)
    # Если покупатель только один, то первую рекламу показываем ему, вторую в любое время с интервалом.
    elif len(events) == 2:
        return (1, events[0][0], events[1][0] + 10,)
    else:
        max_customers = 0
        adv1, adv2 = 0, 0
        unique_customers = set()

        for i in range(len(events)):
            time_1, type_1, index_1 = events[i]
            # Перебираем время прихода всех покупателей и ставим первую рекламу в каждый момент.
            if type_1 == entered:
                # Добавляем покупателя по id в множество.
                unique_customers.add(index_1)
                # Может так получиться, что первая реклама зацепит всех покупателей.
                # Поэтому пробуем обновить ответ.
                if len(unique_customers) > max_customers:
                    max_customers = len(unique_customers)
                    adv1 = time_1
                    # Ставим с интервалом вторую рекламу, если во вложеннм цикле не найдем ей место.
                    adv2 = time_1 + 5
            # Ищем место для показа второй рекламы.
            # Сформированное во внешнем цикле множество не используем,
            # так как показ второй рекламы одному человеку ответ не улучшит.
            # Вместо этого просто считаем покупателей, которые в данный момент находятся в магазине.
            count = 0
            for j in range(i + 1, len(events)):
                time_2, type_2, index_2 = events[j]
                # Если пришел и не смотрел первую рекламу
                if type_2 == entered and index_2 not in unique_customers:
                    count += 1
                # Только если предыдущая реклама закончилась, можно обновлять ответ.
                if time_2 - 5 >= time_1 and len(unique_customers) + count > max_customers:
                    max_customers = len(unique_customers) + count
                    adv1 = time_1
                    adv2 = time_2
                # Если ушел и смотрел первую рекламу
                if type_2 == left and index_2 not in unique_customers:
                    count -= 1
            # Поддерживаем множество покупателей в магазине.
            # Проверять события этого типа раньше обновления ответа нельзя, иначе можно пропустить правильный ответ
            if type_1 == left:
                unique_customers.remove(index_1)
    return (max_customers, adv1, adv2,)
```

## E

На одном из московских вокзалов билеты продают N касс. Каждая касса работает без перерыва определенный промежуток времени по фиксированному расписанию (одному и тому же каждый день). Требуется определить, на протяжении какого времени в течение суток работают все кассы одновременно.

### Формат ввода

Сначала вводится одно целое число N (0 < N ≤ 1000).
В каждой из следующих N строк через пробел расположены 4 целых числа, первые два из которых обозначают время открытия кассы в часах и минутах (часы — целое число от 0 до 23, минуты — целое число от 0 до 59), оставшиеся два — время закрытия в том же формате. Числа разделены пробелами.
Время открытия означает, что в соответствующую ему минуту касса уже работает, а время закрытия — что в соответствующую минуту касса уже не работает. Например, касса, открытая с 10 ч. 30 мин. до 18 ч. 30 мин., ежесуточно работает 480 минут.
Если время открытия совпадает с временем закрытия, то касса работает круглосуточно. Если первое время больше второго, то касса начинает работу до полуночи, а заканчивает — на следующий день.

### Формат вывода

Требуется вывести одно число — суммарное время за сутки (в минутах), на протяжении которого работают все N касс.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 3<br>1 0 23 0<br>12 0 12 0<br>22 0 2 0 | 120 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 2<br>9 30 14 0<br>14 15 21 0 | 0 |

<i>Example 3:</i>

| In                     | Out |
|------------------------|-----|
| 2<br>14 00 18 00<br>10 00 14 01 | 1 |

```python
def main():
    with open('input.txt', 'r') as f:
        number_of_ticket_offices = int(f.readline())
        # Если касс не оказалось
        if number_of_ticket_offices == 0:
            return 0
        
        timeline = list()
        open_ = -1
        close_ = 1
        for _ in range(number_of_ticket_offices):
            time = list(map(int, f.readline().split()))
            start = time[0] * 60 + time[1]
            end = time[2] * 60 + time[3]

            # 1. Если касса открывается до полуночи, а закрывается после,
            # то добавляем событие закрыть кассу в полуночь и открыть ее сразу же после.
            # Таким образом можно обойтись одним проходом.
            # 2. Закрытие кассы в полуночь приходится делать на минуту раньше,
            # чтобы оно после сортировки оказалось в самом конце списка событий.
            # Стандартное закрытие кассы тоже добавляется с минус единицей,
            # чтобы не обрабатывать эти события по-разному
            if start != end:
                if start > end:
                    timeline.append((0, open_))
                    timeline.append((1439, close_))
                timeline.append((start, open_))
                timeline.append((end - 1, close_))
            else:
                # Если касса открытка круглые сутки, 
                # то она никак не влияет на подсчет, поэтому ее вычеркиваем.
                number_of_ticket_offices -= 1

        timeline.sort()
        del start, end, time

    # Если событий нет, значит мы вычеркнули круглосуточные кассы.
    if len(timeline) == 0:
        # Поэтому возвращаем количество минут в сутках
        return 1440
    
    opened_ticket_offices = 0
    concurrent_opened_time = 0
    start = None
    for time_, type_ in timeline:
        if type_ == open_:
            opened_ticket_offices += 1
            if opened_ticket_offices == number_of_ticket_offices:
                # Запоминаем время открытия текущей кассы,
                # если с этого момента открыты все
                start = time_
        if type_ == close_:
            opened_ticket_offices -= 1
            # При закрытии любой кассы, если были открыты все, добавляем к ответу время
            if start is not None:
                concurrent_opened_time += (time_ - start + 1)
                start = None

    return concurrent_opened_time
```

## F

Группа людей называется современниками, если был такой момент, когда они могли собраться все вместе и обсуждать какой-нибудь важный вопрос. Для этого в тот момент, когда они собрались, каждому из них должно было уже исполниться 18 лет, но еще не исполниться 80 лет.
Вам дан список великих людей с датами их жизни. Выведите всевозможные максимальные множества современников. Множество современников будем называть максимальным, если нет другого множества современников, которое включает в себя всех людей из первого множества.
Будем считать, что в день своего 18-летия человек уже может принимать участие в такого рода собраниях, а в день 80-летия, равно как и в день своей смерти, — нет.

### Формат ввода

Сначала на вход программы поступает число N — количество людей (1 ≤ N ≤ 10 000). Далее в N строках вводится по шесть чисел — первые три задают дату (день, месяц, год) рождения, следующие три — дату смерти (она всегда не ранее даты рождения). День (в зависимости от месяца, а в феврале — еще и года) от 1 до 28, 29, 30 или 31, месяц — от 1 до 12, год — от 1 до 2005.

### Формат вывода

Программа должна вывести все максимальные множества современников. Каждое множество должно быть записано на отдельной строке и содержать номера людей (люди во входных данных нумеруются в порядке их задания, начиная с 1). Номера людей должны разделяться пробелами.
Никакое множество не должно быть указано дважды.
Если нет ни одного непустого максимального множества, выведите одно число 0.
Гарантируется, что входные данные будут таковы, что размер выходных данных для правильного ответа не превысит 2 Мб.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 3<br>2 5 1988 13 11 2005<br>1 1 1 1 1 30<br>1 1 1910 1 1 1990 | 2<br>3 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 3<br>2 5 1968 13 11 2005<br>1 1 1 1 1 30<br>1 1 1910 1 1 1990 | 2<br>1 3 |

<i>Example 3:</i>

| In                     | Out |
|------------------------|-----|
| 3<br>2 5 1988 13 11 2005<br>1 1 1 1 1 10<br>2 1 1910 1 1 1928 | 0 |

```python
def get_input():
    number_of_people = int(input())
    people = list()

    for i in range(1, number_of_people + 1):
        Bd, Bm, By, Dd, Dm, Dy = map(int, input().split())
        adulthood = (By + 18, Bm, Bd)
        retire = min((Dy, Dm, Dd), (By + 80, Bm, Bd))
        
        if adulthood < retire:
            people.append([adulthood, 1, i])
            # Человек не может принимать участие в собраниях после 80 или смерти,
            # поэтому этот тип собырия должен стоять раньше
            people.append([retire, 0, i])

    people.sort()
    return people


def main():
    people = get_input()

    if len(people) == 0:
        print(0)
        return
    
    current_set = set()
    last_event = 0

    # Поддерживаем множество людей
    # Если кто-то выходит из множества, и перед ним никто не выходил,
    # то текущее множество не является ничьим подмножеством, и его надо добавить в ответ 
    for person in people:
        if person[1] == 1:
            current_set.add(person[2])
            last_event = 1
        elif person[1] == 0:
            if last_event == 1:
                print(*current_set)
            current_set.remove(person[2])
            last_event = 0
```

## G

Организаторы детского праздника планируют надуть для него M воздушных шариков. С этой целью они пригласили N добровольных помощников, i-й среди которых надувает шарик за T<sub>i</sub> минут, однако каждый раз после надувания Z<sub>i</sub> шариков устает и отдыхает Y<sub>i</sub> минут. Теперь организаторы праздника хотят узнать, через какое время будут надуты все шарики при наиболее оптимальной работе помощников, и сколько шариков надует каждый из них. (Если помощник надул шарик, и должен отдохнуть, но больше шариков ему надувать не придется, то считается, что он закончил работу сразу после окончания надувания последнего шарика, а не после отдыха).

### Формат ввода

В первой строке входных данных задаются числа M и N (0 ≤ M ≤ 15 000, 1 ≤ N ≤ 1000). Следующие N строк содержат по три целых числа - T<sub>i</sub>, Z<sub>i</sub> и Y<sub>i</sub> соответственно (1 ≤ T<sub>i</sub>, Y<sub>i</sub> ≤ 100, 1 ≤ Z<sub>i</sub> ≤ 1000).

### Формат вывода

Выведите в первой строке число T - время, за которое будут надуты все шарики. Во второй строке выведите N чисел - количество шариков, надутых каждым из приглашенных помощников. Разделяйте числа пробелами. Если распределений шариков несколько, выведите любое из них.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 1 2<br>2 1 1<br>1 1 2 | 1<br>0 1 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 2 2<br>1 1 1<br>1 1 1 | 1<br>1 1 |

```python
class Volunteer:
    def __init__(self, work, amount, rest, id_):
        self.work = work
        self.amount = amount
        self.rest = rest
        self.id_ = id_
        self.count = 0


def model(time_, volunteers):
    count = 0
    for i in volunteers:
        # Сколько по времени занимает надуть все шарики перед отдыхом + отдохнуть
        single_chunk = i.work * i.amount + i.rest
        # Сколько таких временных интервалов поместится в текущем временном отрезке
        number_of_chunks = time_ // single_chunk
        # Сколько шаров человек надует за оставшееся у него время.
        # В чанке учитывается время. Так что даже если чанков ноль, волонтер мог успеть надуть все шары перед отдыхом.
        # Чтобы не начислить ему лишнее, берем минимум 
        during_remind_time = min((time_ - (number_of_chunks * single_chunk)) // i.work, i.amount)
        count += number_of_chunks * i.amount + during_remind_time
    return count


def lBinSearch(balloons: int, volunteers: list):
    l = 0
    r = int(15000 * 1100)
    while l < r:
        m = l + (r - l) // 2
        if model(m, volunteers) >= balloons:
            r = m
        else:
            l = m + 1
    return l


def main():
    with open('input.txt', 'r') as f:
        balloons, number_of_volunteers = map(int, f.readline().split())
        # Если надувать нечего, сразу пишем везде нули и дальше ничего не считаем
        if not balloons:
            print(0)
            print(' '.join('0' * number_of_volunteers))
            return

        volunteers = list()
        for i in range(number_of_volunteers):
            work, amount, rest = map(int, f.readline().split())
            volunteers.append(Volunteer(work, amount, rest, i))

    # Бинарным поиском ищем время в минутах, за которое волонтеры надуют нужное количество шаров
    time_passed = lBinSearch(balloons, volunteers)
    print(time_passed)
    
    timeline = list()
    count = 0
    for v in volunteers:
        # Для каждого волонтера смотрим, сколько раз он успеет надуть шары и отдохнуть за все время.
        # Надул шары + отдохнул = один чанк времени
        single_chunk = v.work * v.amount + v.rest
        number_of_chunks = time_passed // single_chunk
        # Сразу же считаем, сколько шаров будет надуто всеми волонтерами за все "временные чанки"
        v.count = number_of_chunks * v.amount
        count += v.count

        # У каждого волонтера может остаться время,
        # когда он не успел надуть все шары перед отдыхом и не успел отдохнуть, а нужное количество шаров уже надуто.
        # Добавляем все моменты времени, когда волонтер надувает шар, в список для каждого волонтера.
        # Начинаем с момента времени, когда волонтер в последний раз успел отдохнуть и надул после отдыха первый шар.
        inflate_timing = (number_of_chunks * single_chunk) + v.work
        for i in range(v.amount):
            timeline.append((inflate_timing, v.id_))
            inflate_timing += v.work

    timeline.sort()
    # Несколько человек могут одновременно закончить надувать последний шар, но учитываться будет только первый из них.
    # Чтобы не проверять на каждой итерации, надули ли нужное количество, сразу отрежем ненужный хвост
    timeline = timeline[:balloons - count]
    for time_, id_ in timeline:
        volunteers[id_].count += 1
    print(' '.join(str(v.count) for v in volunteers))
```

## H

На секретной военной базе работает N охранников. Сутки поделены на 10000 равных промежутков времени, и известно когда каждый из охранников приходит на дежурство и уходит с него. Например, если охранник приходит в 5, а уходит в 8, то значит, что он был в 6, 7 и 8-ой промежуток (а в 5-й нет!!!).
Укажите, верно ли что для данного набора охранников, объект охраняется в любой момент времени хотя бы одним охранником и удаление любого из них приводит к появлению промежутка времени, когда объект не охраняется.

### Формат ввода

В первой строке входного файла записано натуральное число K (1 ≤ K ≤ 100) — количество тестов в файле. Каждый тест начинается с числа N (1 ≤ N ≤ 10 000), за которым следует N пар неотрицательных целых чисел A и B — время прихода на дежурство и ухода (0 ≤ A ≤ B ≤ 10 000) соответствующего охранника.

### Формат вывода

Выведите K строк, где в M-ой строке находится слово Accepted, если M-ый набор охранников удовлетворяет описанным выше условиям. В противном случае выведите Wrong Answer.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 2<br>3 0 3000 2500 7000 2700 10000<br>2 0 3000 2700 10000 | Wrong Answer<br>Accepted |

```python
class Guard:
    def __init__(self, id_):
        self.id_ = id_
        self.alone = False


def pass_test(test: list):
    timeline = list()
    guards = list()
    for j in range(1, test[0] + 1):
        # Время прихода на пост, тип события, инекс охранника
        timeline.append((test[j * 2 - 1], 0, j - 1))
        timeline.append((test[j * 2], 1, j - 1))
        guards.append(Guard(j - 1))
    timeline.sort()

    working_guards = set()
    last_event = -1
    for time_, type_, id_ in timeline:
        # В любой момент, кроме самого первого, должен быть хотя бы один охранник
        if (len(working_guards)) == 0 and (time_ != 0):
            # print('[F] zero guards')
            return False
        # Если охранник один, и от предыдущего события прошло время
        # (либо другой охранник ушел, а считается, что он на посту включая момент ухода,
        # либо текущий охранник пришел, но он, согласно условию, на посту только на следующем промежутке)
        # то ставим ему метку, что он один
        elif (len(working_guards) == 1) and (time_ != last_event):
            guards[list(working_guards)[0]].alone = True
            # print(f'-> guard {list(working_guards)[0]} is alone')
        # print(f'-> guard {id_} has {"left" if type_ else "entered"} at {time_} min')

        if type_ == 0:
            working_guards.add(id_)
        else:
            working_guards.remove(id_)
        # print(f'-> Working guards {len(working_guards)}')

        last_event = time_

    # Последнее событие обязано произойти в последний промежуток суток,
    # иначе расписание набора охранников не удовлетворяет условию
    if timeline[-1][0] != 10000:
        return False

    # Каждый охранник должен был находиться на посту в гордом одиночестве какое-то время, согласно требованиям в условии
    for guard in guards:
        if not guard.alone:
            # print(f'[F] guard {guard.id_} was never alone')
            return False
    return True


def main():
    tests = int(input())
    for _ in range(tests):
        test = list(map(int, input().split()))
        print('Accepted' if pass_test(test) else 'Wrong Answer')
```

## I

Новый Президент Тридевятой республики начал свою деятельность с полной ревизии системы общественного транспорта страны. В результате на основе социологических опросов населения было составлено идеальное ежедневное расписание движения междугородних автобусов, утвержденное Парламентом республики.
Более того, было решено заменить весь автобусный парк одинаковыми новыми, очень дорогими, но гораздо более надежными, красивыми и удобными машинами.
Автобусная сеть страны охватывает N городов, занумерованных целыми числами от 1 до N.
Идеальное расписание содержит M ежедневных рейсов, i-й рейс начинается в городе F<sub>i</sub> в момент времени X<sub>i</sub> и заканчивается в некотором другом городе G<sub>i</sub> в момент времени Y<sub>i</sub>. Продолжительность каждого рейса ненулевая и строго меньше 24 часов. Рейс i выполняется одним из автобусов, находящихся в момент времени X<sub>i</sub> в городе F<sub>i</sub>.
Новые автобусы не требуют ремонта и могут работать круглосуточно, поэтому автобус, прибывший в некоторый момент времени в некоторый город, всегда готов в тот же самый момент времени или позже отправиться в путь для обслуживания любого другого рейса из данного города. Автобус может выехать из города, только выполняя какой-либо рейс из расписания.
Предполагается, что расписание будет действовать неограниченное время, поэтому может оказаться так, что его невозможно обслужить никаким конечным числом автобусов.
Определите наименьшее количество новых автобусов, достаточное для обеспечения движения по расписанию в течение неограниченного периода времени.

### Формат ввода

В первой строке задаются целые числа N и М (1 ≤ N, M ≤ 100 000) — количество городов и рейсов автобусов соответственно.
В каждой из следующих M строк содержится описание рейса автобуса: номер города отправления F<sub>i</sub>, время отправления X<sub>i</sub>, номер города назначения G<sub>i</sub> (F<sub>i</sub> ≠ G<sub>i</sub>), время прибытия Y<sub>i</sub>, отделенные друг от друга одним пробелом. Время прибытия и отправления задается в формате HH:MM, где HH — часы от 00 до 23, MM — минуты от 00 до 59.

### Формат вывода

Выведите одно число — минимально необходимое количество автобусов. Если расписание невозможно обслуживать в течение неограниченного периода времени конечным числом автобусов, выведите число -1.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 2 2<br>2 20:00 1 10:00<br>1 08:00 2 21:00 | 3 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 2 2<br>1 09:00 2 20:00<br>2 20:00 1 09:00 | 1 |

<i>Example 3:</i>

| In                     | Out |
|------------------------|-----|
| 3 4<br>3 03:52 1 08:50<br>1 18:28 3 21:53<br>2 03:58 3 09:00<br>3 14:59 2 21:13 | 2 |

```python
def main():
    number_of_cities, number_of_trips = map(int, input().split())
    cities = [0] * (number_of_cities + 1)
    buses_per_city = [0] * (number_of_cities + 1)
    night_trips = 0
    timeline = list()
    for _ in range(number_of_trips):
        src, departure_time, dst, arrive_time = input().split()
        src = int(src)
        dst = int(dst)
        departure_time = tuple(map(int, departure_time.split(':')))
        arrive_time = tuple(map(int, arrive_time.split(':')))

        # Если в итоге окажется, что количество приехавших и уехавших для каждого города не равно,
        # значит обслужить расписание конечным числом автобусов не получится,
        # ведь они будут скапливаться в каком-то городе
        cities[src] -= 1
        cities[dst] += 1

        # Каждый ночной рейс == +1 автобус
        if departure_time > arrive_time:
            night_trips += 1

        timeline.append((departure_time[0] * 60 + departure_time[1], 1, src))
        timeline.append((arrive_time[0] * 60 + arrive_time[1], 0, dst))
    timeline.sort()

    # Проверка на реализуемость расписания конечным числом автобусов
    for i in cities:
        if i != 0:
            print(-1)
            return

    required_buses = 0
    for time_, type_, city in timeline:
        # Приехал - добавили
        if type_ == 0:
            buses_per_city[city] += 1
        # Уехал - убавили
        else:
            if buses_per_city[city] > 0:
                buses_per_city[city] -= 1
            # Если свободного автобуса в городе в этот момент не было,
            # значит надо добаавить еще один
            else:
                required_buses += 1
            
    # Тот же результат, что при добавлении по одному автобусу, если их не хватает.
    # Работает чуть медленнее, потому что еще один проход
    # for i in buses_per_city:
        # required_buses += i

    print(required_buses + night_trips)
```

## J

Над ареной огромного спортивного комплекса Независимого Главного Университета (НГУ) решили построить перекрытие. Перекрытие будет построено по клеевой технологии и состоять из склеенных друг с другом блоков. Блок представляет собой легкий прямоугольный параллелепипед. Два блока можно склеить, если они соприкасаются перекрывающимися частями боковых граней ненулевой площади.
НГУ представил план комплекса, имеющий вид прямоугольника размером W на L. При этом один из углов прямоугольника находится в начале системы координат, а другой имеет координаты (W, L). Стены комплекса параллельны осям координат.
Подрядчики известили НГУ, что они готовы к определенному сроку изготовить блоки и установить их. Для каждого блока фиксировано место его возможного монтажа, совпадающее по размерам с этим блоком. Места выбраны так, что ребра блоков параллельны осям координат. Места монтажа блоков не пересекаются.

![img](./7_J.gif)

По техническим условиям перекрытие должно состоять из такого набора склеенных блоков, который содержит сплошной горизонтальный слой ненулевой толщины. Торопясь ввести комплекс в эксплуатацию, НГУ решил построить перекрытие из минимально возможного числа блоков.
Требуется написать программу, которая позволяет выбрать минимальное число блоков, которые, будучи установленными на указанных подрядчиками местах, образуют перекрытие, либо определить, что этого сделать невозможно. Высота, на которой образуется перекрытие, не имеет значения.

### Формат ввода

В первой строке входного файла указаны три целых числа: N — количество возможных блоков (1 ≤ N ≤ 10<sup>5</sup>) и размеры комплекса W и L (1 ≤ W, L ≤ 10<sup>4</sup>). Каждая из последующих N строк описывает место монтажа одного блока, определяемое координатами противоположных углов: (x1, y1, z1) и (x2, y2, z2), при этом 0 ≤ x1 < x2 ≤ W, 0 ≤ y1 < y2 ≤ L, 0 ≤ z1 < z2 ≤ 10<sup>9</sup>. Все числа во входном файле целые и разделяются пробелами или переводами строк.
Гарантируется, что места установки блоков не пересекаются друг с другом.

### Формат вывода

Первая строка выходного файла должна содержать либо слово «YES», если перекрытие возможно построить, иначе — слово «NO». В первом случае вторая строка выходного файла должна содержать минимальное число блоков, образующих перекрытие, а последующие строки — номера этих блоков, в соответствии с порядком, в котором они перечислены во входном файле.
Если возможно несколько минимальных наборов блоков, выведите любой из них.

<i>Example 1:</i>

| In                     | Out |
|------------------------|-----|
| 1 10 10<br>0 0 0 10 10 10 | YES<br>1<br>1 |

<i>Example 2:</i>

| In                     | Out |
|------------------------|-----|
| 2 10 10<br>0 0 0 10 5 5<br>0 5 5 10 10 10 | NO |

```python
def main():
    number_of_blocks, width, length = map(int, input().split())
    total_area = width * length

    blocks = list()
    for i in range(1, number_of_blocks + 1):
        x1, y1, z1, x2, y2, z2 = map(int, input().split())
        area = abs(x2 - x1) * abs(y2 - y1)
        blocks.append((z1, 1, area, i))
        blocks.append((z2, 0, area, i))
    blocks.sort()

    # Первый проход
    # Идем по всем блокам и ищем размер самого маленького множества блоков,
    # из которого можно собрать перекрытие
    area = 0
    min_blocks = number_of_blocks + 1
    min_height = -1
    current_number_of_blocks = 0
    filled = False
    for b in blocks:
        if b[1] == 1:
            current_number_of_blocks += 1
            area += b[2]
            if area == total_area:
                filled = True
                if current_number_of_blocks < min_blocks:
                    min_blocks = current_number_of_blocks
                    min_height = b[0]
        else:
            current_number_of_blocks -= 1
            area -= b[2]

    # Второй проход, в котором собираем множество.
    # Два прохода выгоднее в случае,
    # если за первый проход пришлось бы на каждом этапе копировать множество в ответ,
    # что дает квадратичную сложность на копировании 
    if filled:
        print(f'YES\n{min_blocks}')

        current_blocks_set = set()
        for b in blocks:
            if b[1] == 1:
                current_blocks_set.add(b[3])
                if len(current_blocks_set) == min_blocks and b[0] == min_height:
                    print('\n'.join(str(i) for i in current_blocks_set))
                    return
            else:
                current_blocks_set.remove(b[3])
    else:
        print('NO')
```